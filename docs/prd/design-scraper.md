# çˆ¬è™«æ¶æ„è®¾è®¡è§„èŒƒ

> æœ¬æ–‡æ¡£æ•´åˆäº†åå·èººå¹³å¯è§†åŒ–ç³»ç»Ÿçš„æ‰€æœ‰çˆ¬è™«æŠ€æœ¯æ–¹æ¡ˆï¼ŒåŒ…æ‹¬æ¶æ„è®¾è®¡ã€å®ç°ç»†èŠ‚å’Œæœ€ä½³å®è·µ

## ğŸ¯ çˆ¬è™«æŠ€æœ¯é€‰å‹

### æ ¸å¿ƒæŠ€æœ¯æ ˆ

#### 1. Playwright âœ… å¼ºçƒˆæ¨è
**é€‰æ‹©ç†ç”±**ï¼š
- âœ… **ç°ä»£åŒ–**ï¼šæ”¯æŒæœ€æ–°æµè§ˆå™¨ï¼ˆChromeã€Firefoxã€WebKitï¼‰
- âœ… **ååçˆ¬èƒ½åŠ›å¼º**ï¼šå†…ç½®åæ£€æµ‹æœºåˆ¶
- âœ… **å¤šè¯­è¨€æ”¯æŒ**ï¼šNode.jsã€Pythonã€Javaã€C#
- âœ… **æˆªå›¾åŠŸèƒ½**ï¼šå®Œç¾é…åˆAIè¯†åˆ«æ–¹æ¡ˆ
- âœ… **ç¤¾åŒºæ´»è·ƒ**ï¼šå¾®è½¯ç»´æŠ¤ï¼Œæ–‡æ¡£å®Œå–„

**ä¸å…¶ä»–å·¥å…·å¯¹æ¯”**ï¼š
| ç‰¹æ€§ | Playwright | Puppeteer | Selenium |
|------|-----------|----------|---------|
| ååçˆ¬èƒ½åŠ› | â­â­â­â­ | â­â­â­ | â­â­â­â­ |
| æˆªå›¾åŠŸèƒ½ | â­â­â­â­â­ | â­â­â­ | â­â­ |
| APIè®¾è®¡ | â­â­â­â­ | â­â­â­ | â­â­ |
| å­¦ä¹ æ›²çº¿ | â­â­â­ | â­â­â­ | â­â­ |

#### 2. AIè¯†åˆ«æ–¹æ¡ˆ âœ¨ åˆ›æ–°æ¨è
**æˆªå›¾+AIè¯†åˆ«**ï¼š
- âœ… **ç»•è¿‡åçˆ¬**ï¼šæˆªå›¾è€Œéè§£æHTMLï¼Œéš¾ä»¥è¢«æ£€æµ‹
- âœ… **å¤„ç†å¤æ‚é¡µé¢**ï¼šæ— éœ€è§£æJavaScriptæ¸²æŸ“å†…å®¹
- âœ… **æˆæœ¬ä½å»‰**ï¼šAI APIè´¹ç”¨çº¦$2-5/æœˆ
- âœ… **ç»´æŠ¤ç®€å•**ï¼šæ— éœ€é¢‘ç¹æ›´æ–°é€‰æ‹©å™¨

---

## ğŸ—ï¸ çˆ¬è™«æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åå·èººå¹³ç³»ç»Ÿçˆ¬è™«æ¶æ„                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  å‰ç«¯ç•Œé¢    â”‚  â”‚  åç«¯API     â”‚  â”‚        çˆ¬è™«æœåŠ¡              â”‚  â”‚
â”‚  â”‚  (SvelteKit) â”‚  â”‚  (Express)    â”‚  â”‚      (Playwright)           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚        â”‚              â”‚                â”‚             â”‚  â”‚
â”‚   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ æ‰‹åŠ¨è§¦å‘  â”‚   â”‚   å®šæ—¶ä»»åŠ¡   â”‚   â”‚   AIè¯†åˆ«æœåŠ¡   â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚        â”‚              â”‚                â”‚             â”‚  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚  çˆ¬è™«ç®¡ç†  â”‚   â”‚  â”‚  æ•°æ®åº“     â”‚  â”‚   â”‚  ç¼“å­˜     â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚  (PostgreSQL) â”‚  â”‚   â”‚ (Redis)   â”‚  â”‚
â”‚        â”‚              â”‚                â”‚             â”‚  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚  æ—¥å¿—ç³»ç»Ÿ  â”‚   â”‚  â”‚  ç›‘æ§å‘Šè­¦   â”‚  â”‚  â”‚ ä»£ç†æ±      â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚  â”‚ (Sentry)    â”‚  â”‚  â”‚ (å¯é€‰)    â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç›®å½•ç»“æ„

```
project-root/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ routes/api/
â”‚       â””â”€â”€ scraper/
â”‚           +page.svelte      # çˆ¬è™«ç®¡ç†ç•Œé¢
â”‚           +page.svelte      # çˆ¬è™«æ—¥å¿—
â”‚
â”œâ”€â”€ scripts/                    # çˆ¬è™«è„šæœ¬ç›®å½•
â”‚   â”œâ”€â”€ index.js               # çˆ¬è™«ä¸»å…¥å£
â”‚   â”œâ”€â”€ config.js              # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ utils.js               # å·¥å…·å‡½æ•°
â”‚   â”‚
â”‚   â”œâ”€â”€ weather.js              # å¤©æ°”çˆ¬è™«
â”‚   â”œâ”€â”€ housing.js              # æˆ¿ä»·çˆ¬è™«
â”‚   â”œâ”€â”€ xiaohongshu.js          # å°çº¢ä¹¦çˆ¬è™«
â”‚   â”œâ”€â”€ weibo.js                # å¾®åšçˆ¬è™«
â”‚   â”œâ”€â”€ news.js                 # æ–°é—»çˆ¬è™«
â”‚   â””â”€â”€ ai-scraper.js           # AIè¯†åˆ«çˆ¬è™«
â”‚
â”‚   â”œâ”€â”€ screenshots/            # çˆ¬è™«æˆªå›¾å­˜å‚¨
â”‚   â”‚   â”œâ”€â”€ xiaohongshu/
â”‚   â”‚   â”œâ”€â”€ weibo/
â”‚   â”‚   â””â”€â”€ housing/
â”‚   â”‚
â”‚   â””â”€â”€ logs/                  # çˆ¬è™«æ—¥å¿—
â”‚       â”œâ”€â”€ scraper.log
â”‚       â””â”€â”€ error.log
â”‚
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ scraper.js              # çˆ¬è™«æ ¸å¿ƒåº“
â”‚   â”œâ”€â”€ ai-recognizer.js         # AIè¯†åˆ«æœåŠ¡
â”‚   â”œâ”€â”€ proxy-manager.js         # ä»£ç†ç®¡ç†
â”‚   â””â”€â”€ scheduler.js            # å®šæ—¶ä»»åŠ¡
â”‚
â””â”€â”€ prisma/schema.prisma         # æ•°æ®åº“æ¨¡å‹
```

---

## ğŸ”§ æ ¸å¿ƒçˆ¬è™«å®ç°

### 1. åŸºç¡€çˆ¬è™«æ¡†æ¶

```javascript
// scripts/utils.js
import { chromium } from 'playwright';
import { config } from './config';

/**
 * åˆ›å»ºæµè§ˆå™¨å®ä¾‹
 */
export async function createBrowser() {
  const browser = await chromium.launch({
    headless: config.headless,
    slowMo: config.slowMo,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
      '--disable-gpu',
      '--window-size=1920,1080',
      '--user-agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    ]
  });

  const context = await browser.newContext({
    viewport: { width: 1920, height: 1080 },
    userAgent: config.userAgent,
    ignoreHTTPSErrors: true
  });

  const page = await context.newPage();
  
  // è®¾ç½®è¯·æ±‚æ‹¦æˆª
  await page.route('**/*.{png,jpg,jpeg,gif,svg,css,js,font}', route => route.abort());
  
  return { browser, context, page };
}

/**
 * å®‰å…¨å…³é—­æµè§ˆå™¨
 */
export async function closeBrowser(browser, context) {
  if (context) await context.close();
  if (browser) await browser.close();
}

/**
 * éšæœºå»¶è¿Ÿ
 */
export function randomDelay(min = 1000, max = 3000) {
  const delay = Math.floor(Math.random() * (max - min + 1)) + min;
  return new Promise(resolve => setTimeout(resolve, delay));
}

/**
 * è®°å½•çˆ¬è™«æ—¥å¿—
 */
export async function logScraperEvent(scraperName, status, details = {}) {
  const logData = {
    scraper_name: scraperName,
    status,
    details,
    timestamp: new Date().toISOString()
  };
  
  console.log(`[${scraperName}] ${status}:`, details);
  
  // å­˜å‚¨åˆ°æ•°æ®åº“
  try {
    await fetch('/api/scraper/logs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(logData)
    });
  } catch (error) {
    console.error('Failed to log scraper event:', error);
  }
}
```

### 2. AIè¯†åˆ«çˆ¬è™«æ¡†æ¶

```javascript
// scripts/ai-recognizer.js
import { config } from './config';

/**
 * AIè¯†åˆ«æœåŠ¡
 */
class AIRecognizer {
  constructor() {
    this.apiKey = config.aiApiKey;
    this.cache = new Map(); // 24å°æ—¶ç¼“å­˜
  }

  /**
   * è¯†åˆ«å›¾ç‰‡ä¸­çš„æ–‡æœ¬
   */
  async recognizeImage(imageBuffer, prompt) {
    const cacheKey = this.generateCacheKey(imageBuffer, prompt);
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
        return cached.result;
      }
    }

    try {
      // è½¬æ¢ä¸ºbase64
      const base64 = imageBuffer.toString('base64');
      
      // è°ƒç”¨AI API
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: 'claude-3-opus-20240229',
          max_tokens: 4000,
          messages: [
            {
              role: 'user',
              content: [
                {
                  type: 'text',
                  text: prompt
                },
                {
                  type: 'image',
                  source: {
                    type: 'base64',
                    media_type: 'image/png',
                    data: base64
                  }
                }
              ]
            }
          ]
        })
      });

      const data = await response.json();
      const result = data.content[0].text;
      
      // ç¼“å­˜ç»“æœ
      this.cache.set(cacheKey, {
        result,
        timestamp: Date.now()
      });

      return result;
      
    } catch (error) {
      console.error('AI recognition failed:', error);
      throw new Error(`AIè¯†åˆ«å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * ç”Ÿæˆç¼“å­˜é”®
   */
  generateCacheKey(imageBuffer, prompt) {
    const crypto = require('crypto');
    const hash = crypto.createHash('md5');
    hash.update(imageBuffer);
    hash.update(prompt);
    return hash.digest('hex');
  }
}

export const aiRecognizer = new AIRecognizer();
```

### 3. å°çº¢ä¹¦çˆ¬è™«å®ç°

```javascript
// scripts/xiaohongshu.js
import { createBrowser, closeBrowser, randomDelay, logScraperEvent } from './utils.js';
import { aiRecognizer } from './ai-recognizer.js';

/**
 * å°çº¢ä¹¦ç¬”è®°çˆ¬è™«
 */
export async function scrapeXiaohongshu(cityName, limit = 20) {
  const scraperName = 'xiaohongshu';
  let browser, context, page;
  
  try {
    // è®°å½•å¼€å§‹
    await logScraperEvent(scraperName, 'running', {
      city: cityName,
      limit
    });

    // åˆ›å»ºæµè§ˆå™¨
    ({ browser, context, page } = await createBrowser());
    
    // è®¿é—®å°çº¢ä¹¦æœç´¢é¡µé¢
    const searchUrl = `https://www.xiaohongshu.com/search_result?keyword=${encodeURIComponent(cityName)}ç”Ÿæ´»`;
    await page.goto(searchUrl);
    
    // ç­‰å¾…æœç´¢ç»“æœåŠ è½½
    await page.waitForSelector('.note-item', { timeout: 10000 });
    
    // è·å–ç¬”è®°åˆ—è¡¨
    const notes = await page.$$('.note-item');
    const results = [];
    
    for (let i = 0; i < Math.min(notes.length, limit); i++) {
      try {
        const note = notes[i];
        
        // æå–åŸºæœ¬ä¿¡æ¯
        const title = await note.$eval(el => el.querySelector('.title').innerText);
        const likes = await note.$eval(el => {
          const likesEl = el.querySelector('.likes');
          return likesEl ? parseInt(likesEl.innerText) : 0;
        });
        const author = await note.$eval(el => {
          const authorEl = el.querySelector('.author-name');
          return authorEl ? authorEl.innerText.trim() : '';
        });
        
        // æˆªå›¾
        const screenshot = await note.screenshot({
          path: `./screenshots/xiaohongshu/${cityName}_${i}.png`
        });
        
        // AIè¯†åˆ«è¯¦ç»†ä¿¡æ¯
        const aiPrompt = `
          è¯·ä»è¿™ä¸ªå°çº¢ä¹¦ç¬”è®°æˆªå›¾ä¸­æå–ä»¥ä¸‹ä¿¡æ¯ï¼š
          1. ç¬”è®°æ ‡é¢˜ï¼ˆå¦‚æœæœ‰ï¼‰
          2. ä½œè€…åç§°
          3. ç‚¹èµæ•°
          4. ç®€çŸ­å†…å®¹æ‘˜è¦ï¼ˆå‰100å­—ï¼‰
          5. æ ‡ç­¾ï¼ˆå¦‚æœæœ‰ï¼‰
          
          è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œå­—æ®µåŒ…æ‹¬ï¼štitle, author, likes, content, tags
        `;
        
        const imageBuffer = await screenshot.screenshot();
        const aiResult = await aiRecognizer.recognizeImage(imageBuffer, aiPrompt);
        
        let extraInfo = {};
        try {
          extraInfo = JSON.parse(aiResult);
        } catch (error) {
          console.warn('AIè§£æå¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€ä¿¡æ¯');
        }
        
        results.push({
          city: cityName,
          platform: 'xiaohongshu',
          title: title,
          likes: likes,
          author: author,
          content: extraInfo.content || '',
          tags: extraInfo.tags || [],
          screenshot: screenshotPath,
          timestamp: new Date().toISOString(),
          scraped_at: new Date().toISOString()
        });
        
        // éšæœºå»¶è¿Ÿ
        await randomDelay(2000, 5000);
        
      } catch (error) {
        console.error(`å¤„ç†ç¬”è®° ${i} æ—¶å‡ºé”™:`, error);
        continue;
      }
    }
    
    // è®°å½•æˆåŠŸ
    await logScraperEvent(scraperName, 'success', {
      city: cityName,
      count: results.length,
      items: results.map(r => ({
        title: r.title,
        likes: r.likes
      }))
    });
    
    return results;
    
  } catch (error) {
    await logScraperEvent(scraperName, 'failure', {
      error: error.message
    });
    throw error;
    
  } finally {
    await closeBrowser(browser, context);
  }
}
```

### 4. å¾®åšçˆ¬è™«å®ç°

```javascript
// scripts/weibo.js
import { createBrowser, closeBrowser, randomDelay, logScraperEvent } from './utils.js';

/**
 * å¾®åšæœç´¢çˆ¬è™«
 */
export async function scrapeWeibo(cityName, limit = 20) {
  const scraperName = 'weibo';
  let browser, context, page;
  
  try {
    await logScraperEvent(scraperName, 'running', {
      city: cityName,
      limit
    });

    ({ browser, context, page } = await createBrowser());
    
    // è®¿é—®å¾®åšæœç´¢é¡µé¢
    const searchUrl = `https://s.weibo.com/search?q=${encodeURIComponent(cityName)}ç”Ÿæ´»&type=user`;
    await page.goto(searchUrl);
    
    // ç­‰å¾…æœç´¢ç»“æœåŠ è½½
    await page.waitForSelector('.card-wrap', { timeout: 10000 });
    
    const results = [];
    const posts = await page.$$('.card-wrap');
    
    for (let i = 0; i < Math.min(posts.length, limit); i++) {
      try {
        const post = posts[i];
        
        // æå–å¾®åšä¿¡æ¯
        const content = await post.$eval(el => el.querySelector('.content').innerText);
        const author = await post.$eval(el => {
          const authorEl = el.querySelector('.name');
          return authorEl ? authorEl.innerText.trim() : '';
        });
        const stats = await post.$eval(el => {
          const actions = el.querySelectorAll('.card-act');
          return {
            reposts: actions[0]?.innerText || '0',
            comments: actions[1]?.innerText || '0',
            likes: actions[2]?.innerText || '0'
          };
        });
        
        results.push({
          city: cityName,
          platform: 'weibo',
          content: content,
          author: author,
          reposts: parseInt(stats.reposts),
          comments: parseInt(stats.comments),
          likes: parseInt(stats.likes),
          timestamp: new Date().toISOString(),
          scraped_at: new Date().toISOString()
        });
        
        await randomDelay(1500, 3000);
        
      } catch (error) {
        console.error(`å¤„ç†å¾®åš ${i} æ—¶å‡ºé”™:`, error);
        continue;
      }
    }
    
    await logScraperEvent(scraperName, 'success', {
      city: cityName,
      count: results.length
    });
    
    return results;
    
  } catch (error) {
    await logScraperEvent(scraperName, 'failure', {
      error: error.message
    });
    throw error;
    
  } finally {
    await closeBrowser(browser, context);
  }
}
```

### 5. æˆ¿ä»·çˆ¬è™«å®ç°

```javascript
// scripts/housing.js
import { createBrowser, closeBrowser, randomDelay, logScraperEvent } from './utils.js';

/**
 * è´å£³æˆ¿ä»·çˆ¬è™«
 */
export async function scrapeHousing(cityName, districts = []) {
  const scraperName = 'housing';
  let browser, context, page;
  
  try {
    await logScraperEvent(scraperName, 'running', {
      city: cityName,
      districts
    });

    ({ browser, context, page } = await createBrowser());
    
    // è®¿é—®è´å£³åŸå¸‚é¡µé¢
    const cityUrl = `https://${cityName}.ke.com/ershoufang/`;
    await page.goto(cityUrl);
    
    // ç­‰å¾…é¡µé¢åŠ è½½
    await page.waitForSelector('.listContent', { timeout: 10000 });
    
    const results = [];
    
    // å¦‚æœæ²¡æœ‰æŒ‡å®šåŒºåŸŸï¼Œè·å–æ‰€æœ‰åŒºåŸŸ
    if (districts.length === 0) {
      const districtElements = await page.$('.listContent .filter');
      districts = await Promise.all(
        districtElements.map(el => el.$eval(el => el.innerText.trim()))
      );
    }
    
    for (const district of districts) {
      try {
        // ç‚¹å‡»åŒºåŸŸ
        await page.click(`text="${district}"`);
        await page.waitForTimeout(2000);
        
        // è·å–ä»·æ ¼ä¿¡æ¯
        const priceElement = await page.$('.total .total');
        const price = priceElement ? 
          parseInt(priceElement.innerText.replace(/[^0-9]/g, '')) : 0;
        
        // è·å–æˆ¿æºæ•°é‡
        const countElement = await page.$('.list .total');
        const count = countElement ? 
          parseInt(countElement.innerText.replace(/[^0-9]/g, '')) : 0;
        
        if (price > 0) {
          results.push({
            city: cityName,
            district: district,
            price: price,
            count: count,
            date: new Date().toISOString().split('T')[0],
            scraped_at: new Date().toISOString()
          });
        }
        
        await randomDelay(1000, 2000);
        
      } catch (error) {
        console.error(`å¤„ç†åŒºåŸŸ ${district} æ—¶å‡ºé”™:`, error);
        continue;
      }
    }
    
    await logScraperEvent(scraperName, 'success', {
      city: cityName,
      districts: districts.length,
      results: results.length
    });
    
    return results;
    
  } catch (error) {
    await logScraperEvent(scraperName, 'failure', {
      error: error.message
    });
    throw error;
    
  } finally {
    await closeBrowser(browser, context);
  }
}
```

---

## ğŸ›¡ï¸ ååçˆ¬ç­–ç•¥

### 1. æµè§ˆå™¨ä¼ªè£…

```javascript
// scripts/utils.js
export const browserConfig = {
  // éšæœºç”¨æˆ·ä»£ç†
  userAgent: [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
  ],
  
  // éšæœºè§†çª—å¤§å°
  viewports: [
    { width: 1920, height: 1080 },
    { width: 1366, height: 768 },
    { width: 1280, height: 720 }
  ],
  
  // éšæœºè¯­è¨€å’Œæ—¶åŒº
  locales: ['zh-CN', 'en-US'],
  
  // éšæœºæ—¶åŒº
  timezones: ['Asia/Shanghai', 'America/New_York', 'Europe/London']
};

/**
 * è·å–éšæœºé…ç½®
 */
export function getRandomConfig() {
  const config = {
    userAgent: browserConfig.userAgents[
      Math.floor(Math.random() * browserConfig.userAgents.length)
    ],
    viewport: browserConfig.viewports[
      Math.floor(Math.random() * browserConfig.viewports.length)
    ],
    locale: browserConfig.locales[
      Math.floor(Math.random() * browserConfig.locales.length)
    ]
  };
  
  return config;
}
```

### 2. è¯·æ±‚é¢‘ç‡æ§åˆ¶

```javascript
// scripts/config.js
export const config = {
  // è¯·æ±‚é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  delays: {
    xiaohongshu: { min: 2000, max: 5000 },
    weibo: { min: 1500, max: 3000 },
    housing: { min: 1000, max: 2000 },
    news: { min: 500, max: 1500 }
  },
  
  // æ¯æ—¥æœ€å¤§è¯·æ±‚æ•°
  dailyLimits: {
    xiaohongshu: 100,
    weibo: 200,
    housing: 50,
    news: 500
  },
  
  // ä»£ç†æ± é…ç½®
  proxyPool: [
    'http://proxy1.example.com:8080',
    'http://proxy2.example.com:8080',
    'http://proxy3.example.com:8080'
  ],
  
  // å¤±è´¥é‡è¯•é…ç½®
  retry: {
    maxAttempts: 3,
    backoff: 'exponential',
    initialDelay: 1000
  }
};

/**
 * æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æ¯æ—¥é™åˆ¶
 */
export function checkDailyLimit(scraperName) {
  const today = new Date().toISOString().split('T')[0];
  const key = `scraper_${scraperName}_${today}`;
  
  const used = parseInt(localStorage.getItem(key) || '0');
  const limit = config.dailyLimits[scraperName] || Infinity;
  
  if (used >= limit) {
    throw new Error(`æ¯æ—¥é™åˆ¶å·²è¾¾åˆ°: ${limit}/${used}`);
  }
  
  localStorage.setItem(key, used + 1);
  return { used: used + 1, limit };
}
```

### 3. ä»£ç†IPè½®æ¢

```javascript
// scripts/proxy-manager.js
class ProxyManager {
  constructor(proxyList) {
    this.proxies = proxyList;
    this.currentIndex = 0;
    this.failedProxies = new Set();
  }

  /**
   * è·å–ä¸‹ä¸€ä¸ªå¯ç”¨ä»£ç†
   */
  getNextProxy() {
    const availableProxies = this.proxies.filter(p => !this.failedProxies.has(p));
    
    if (availableProxies.length === 0) {
      throw new Error('æ‰€æœ‰ä»£ç†éƒ½ä¸å¯ç”¨');
    }
    
    const proxy = availableProxies[this.currentIndex % availableProxies.length];
    this.currentIndex++;
    
    return proxy;
  }

  /**
   * æ ‡è®°ä»£ç†å¤±è´¥
   */
  markProxyFailed(proxy) {
    this.failedProxies.add(proxy);
    console.warn(`ä»£ç†å¤±è´¥: ${proxy}`);
  }

  /**
   * é‡ç½®å¤±è´¥çŠ¶æ€
   */
  resetFailedProxies() {
    this.failedProxies.clear();
    this.currentIndex = 0;
  }

  /**
   * è·å–ä»£ç†é…ç½®
   */
  getProxyConfig(proxy) {
    return {
      proxy: {
        server: proxy,
        bypass: ['localhost', '127.0.0.1']
      }
    };
  }
}

export const proxyManager = new ProxyManager(config.proxyPool);
```

### 4. éªŒè¯ç å¤„ç†

```javascript
// scripts/captcha-handler.js
import { createBrowser } from './utils.js';

class CaptchaHandler {
  constructor() {
    this.ocrSpace = 'https://api.ocr.space/parse/image';
  }

  /**
   * è¯†åˆ«éªŒè¯ç 
   */
  async recognizeCaptcha(imageBuffer) {
    try {
      const formData = new FormData();
      formData.append('file', imageBuffer, 'captcha.png');
      
      const response = await fetch(this.ocrSpace, {
        method: 'POST',
        body: formData
      });
      
      const result = await response.json();
      return result.ParsedResults[0]?.ParsedText || '';
      
    } catch (error) {
      console.error('éªŒè¯ç è¯†åˆ«å¤±è´¥:', error);
      return null;
    }
  }

  /**
   * å¤„ç†æ»‘å—éªŒè¯ç 
   */
  async handleSlider(page, selector) {
    try {
      // ç­‰å¾…æ»‘å—å‡ºç°
      await page.waitForSelector(selector, { timeout: 10000 });
      
      // è·å–æ»‘å—å…ƒç´ 
      const slider = await page.$(selector);
      
      // è·å–æ»‘å—è½¨é“
      const track = await slider.$eval(el => {
        const trackEl = el.querySelector('.nc_iconfont');
        const trackRect = trackEl.getBoundingClientRect();
        const sliderEl = el.querySelector('.nc_iconfont');
        const sliderRect = sliderEl.getBoundingClientRect();
        return {
          track: { x: trackRect.left, width: trackRect.width },
          slider: { x: sliderRect.left, width: sliderRect.width }
        };
      });
      
      // è®¡ç®—ç›®æ ‡ä½ç½®ï¼ˆé€šå¸¸æ»‘å—éœ€è¦æ»‘åˆ°æœ€å³ç«¯ï¼‰
      const targetX = track.track.x + track.width - track.slider.width / 2;
      
      // æ‹–åŠ¨æ»‘å—
      await slider.hover();
      await page.mouse.move(targetX, track.track.y);
      await page.mouse.up();
      
      // ç­‰å¾…éªŒè¯
      await page.waitForTimeout(2000);
      
      return true;
      
    } catch (error) {
      console.error('æ»‘å—éªŒè¯å¤±è´¥:', error);
      return false;
    }
  }
}

export const captchaHandler = new CaptchaHandler();
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. å¹¶å‘æ§åˆ¶

```javascript
// scripts/scheduler.js
import { checkDailyLimit } from './config.js';

class ScraperScheduler {
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent;
    this.running = [];
    this.queue = [];
  }

  /**
   * æ·»åŠ çˆ¬è™«ä»»åŠ¡
   */
  addTask(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, resolve, reject });
      this.processQueue();
    });
  }

  /**
   * å¤„ç†é˜Ÿåˆ—
   */
  async processQueue() {
    if (this.running.length >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }

    const { task, resolve, reject } = this.queue.shift();
    this.running.push({ task, resolve, reject });
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      const index = this.running.findIndex(item => item.task === task);
      if (index > -1) {
        this.running.splice(index, 1);
      }
      this.processQueue();
    }
  }

  /**
   * ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
   */
  async waitForAll() {
    while (this.running.length > 0 || this.queue.length > 0) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

export const scheduler = new ScraperScheduler();
```

### 2. ç¼“å­˜ç­–ç•¥

```javascript
// scripts/cache-manager.js
const cache = new Map();

export const cacheManager = {
  /**
   * è®¾ç½®ç¼“å­˜
   */
  set(key, value, ttl = 24 * 60 * 60 * 1000) {
    const expiry = Date.now() + ttl;
    cache.set(key, { value, expiry });
  },

  /**
   * è·å–ç¼“å­˜
   */
  get(key) {
    const item = cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      cache.delete(key);
      return null;
    }
    
    return item.value;
  },

  /**
   * åˆ é™¤ç¼“å­˜
   */
  delete(key) {
    cache.delete(key);
  },

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  cleanup() {
    const now = Date.now();
    for (const [key, item] of cache.entries()) {
      if (now > item.expiry) {
        cache.delete(key);
      }
    }
  }
};

// å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜
setInterval(() => {
  cacheManager.cleanup();
}, 60 * 60 * 1000); // æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡
```

### 3. é”™è¯¯å¤„ç†å’Œé‡è¯•

```javascript
// scripts/retry-handler.js
export async function withRetry(fn, maxAttempts = 3, backoff = 'exponential') {
  let lastError;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      if (attempt === maxAttempts) {
        throw error;
      }
      
      const delay = backoff === 'exponential' 
        ? Math.min(1000 * Math.pow(2, attempt - 1), 30000)
        : 1000 * attempt;
      
      console.log(`ç¬¬ ${attempt} æ¬¡å°è¯•å¤±è´¥ï¼Œ${delay}msåé‡è¯•`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

/**
 * æŒ‡æ•°é€€é¿ç®—æ³•
 */
function exponentialBackoff(attempt, baseDelay = 1000, maxDelay = 30000) {
  return Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay);
}
```

---

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### 1. çˆ¬è™«æ—¥å¿—è¡¨è®¾è®¡

```sql
CREATE TABLE scraper_logs (
  id SERIAL PRIMARY KEY,
  scraper_name VARCHAR(100) NOT NULL,
  city_id INTEGER REFERENCES cities(id),
  
  status VARCHAR(20),  -- running/success/failure/timeout
  start_time TIMESTAMP,
  end_time TIMESTAMP,
  duration INTEGER,  -- è€—æ—¶(ç§’)
  
  items_scraped INTEGER DEFAULT 0,
  pages_scraped INTEGER DEFAULT 0,
  
  error_message TEXT,
  error_trace TEXT,
  
  created_at TIMESTAMP DEFAULT NOW(),
  created_at DATE  -- åˆ†åŒºé”®
);

-- ç´¢å¼•
CREATE INDEX idx_logs_scraper ON scraper_logs(scraper_name);
CREATE INDEX idx_logs_status ON scraper_logs(status);
CREATE INDEX idx_logs_date ON scraper_logs(created_at DESC);
```

### 2. æ—¥å¿—æœåŠ¡

```javascript
// scripts/logger.js
class ScraperLogger {
  constructor() {
    this.logLevel = process.env.SCRAPER_LOG_LEVEL || 'info';
  }

  log(level, scraperName, message, data = {}) {
    if (!this.shouldLog(level)) return;

    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      scraper: scraperName,
      message,
      data,
      stack: new Error().stack
    };

    console.log(`[${level.toUpperCase()}] [${scraperName}] ${message}`, data);

    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    this.sendToMonitoring(logEntry);
  }

  info(scraperName, message, data) {
    this.log('info', scraperName, message, data);
  }

  error(scraperName, error, data) {
    this.log('error', scraperName, error.message, {
      ...data,
      stack: error.stack
    });
  }

  warn(scraperName, message, data) {
    this.log('warn', scraperName, message, data);
  }

  debug(scraperName, message, data) {
    this.log('debug', scraperName, message, data);
  }

  shouldLog(level) {
    const levels = ['debug', 'info', 'warn', 'error'];
    const currentLevelIndex = levels.indexOf(this.logLevel);
    const targetLevelIndex = levels.indexOf(level);
    return targetLevelIndex >= currentLevelIndex;
  }

  sendToMonitoring(logEntry) {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿï¼ˆå¦‚Sentryï¼‰
    if (process.env.SENTRY_DSN) {
      // Sentryé›†æˆä»£ç 
    }
  }
}

export const logger = new ScraperLogger();
```

### 3. å‘Šè­¦ç³»ç»Ÿ

```javascript
// scripts/alerting.js
class AlertManager {
  constructor() {
    this.thresholds = {
      errorRate: 0.1,      // é”™è¯¯ç‡10%
      failureCount: 5,     // è¿ç»­å¤±è´¥5æ¬¡
      duration: 300000     // è¶…æ—¶5åˆ†é’Ÿ
    };
  }

  /**
   * æ£€æŸ¥å‘Šè­¦æ¡ä»¶
   */
  async checkAlerts(scraperName, metrics) {
    // æ£€æŸ¥é”™è¯¯ç‡
    if (metrics.errorRate > this.thresholds.errorRate) {
      await this.sendAlert('error_rate', {
        scraper: scraperName,
        errorRate: metrics.errorRate,
        threshold: this.thresholds.errorRate
      });
    }

    // æ£€æŸ¥è¿ç»­å¤±è´¥
    if (metrics.consecutiveFailures >= this.thresholds.failureCount) {
      await this.sendAlert('consecutive_failures', {
        scraper: scraperName,
        count: metrics.consecutiveFailures,
        threshold: this.thresholds.failureCount
      });
    }

    // æ£€æŸ¥è¶…æ—¶
    if (metrics.avgDuration > this.thresholds.duration) {
      await this.sendAlert('long_duration', {
        scraper: scraperName,
        avgDuration: metrics.avgDuration,
        threshold: this.thresholds.duration
      });
    }
  }

  /**
   * å‘é€å‘Šè­¦
   */
  async sendAlert(type, data) {
    const alert = {
      type,
      timestamp: new Date().toISOString(),
      severity: type === 'error_rate' ? 'critical' : 'warning',
      message: this.formatMessage(type, data),
      data
    };

    // å‘é€åˆ°é€šçŸ¥ç³»ç»Ÿ
    await this.notify(alert);
    
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    await this.monitoring(alert);
  }

  formatMessage(type, data) {
    switch (type) {
      case 'error_rate':
        return `çˆ¬è™«é”™è¯¯ç‡è¿‡é«˜: ${data.scraper} é”™è¯¯ç‡ ${(data.errorRate * 100).toFixed(1)}%`;
      case 'consecutive_failures':
        return `çˆ¬è™«è¿ç»­å¤±è´¥: ${data.scraper} å·²è¿ç»­å¤±è´¥ ${data.count} æ¬¡`;
      case 'long_duration':
        return `çˆ¬è€—æ—¶é•¿: ${data.scraper} å¹³å‡è€—æ—¶ ${Math.round(data.avgDuration / 1000)}ç§’`;
      default:
        return `çˆ¬è™«å‘Šè­¦: ${JSON.stringify(data)}`;
    }
  }

  async notify(alert) {
    // å‘é€é‚®ä»¶ã€é’‰é’‰ã€ä¼ä¸šå¾®ä¿¡ç­‰
    console.log('ğŸš¨ ALERT:', alert.message);
  }

  async monitoring(alert) {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    console.log('ğŸ“Š MONITOR:', alert);
  }
}

export const alertManager = new AlertManager();
```

---

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### 1. æœ¬åœ°éƒ¨ç½²

```bash
# package.json scripts
{
  "scripts": {
    "scrape": "node scripts/index.js",
    "scrape:schedule": "node scripts/scheduler.js",
    "scrape:logs": "node scripts/logger.js"
  }
}

# å¯åŠ¨å®šæ—¶ä»»åŠ¡
npm run scrape:schedule
```

### 2. GitHub Actionséƒ¨ç½²

```yaml
# .github/workflows/scraper.yml
name: çˆ¬è™«å®šæ—¶ä»»åŠ¡

on:
  schedule:
  # æ¯å¤©å‡Œæ™¨2ç‚¹è¿è¡Œ
  - cron: '0 2 * * *'
  # æ‰‹åŠ¨è§¦å‘
  - workflow_dispatch

jobs:
  scrape:
    runs-on: ubuntu-latest
    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: å®‰è£…ä¾èµ–
        run: |
          npm install
          npx playwright install chromium

      - name: è¿è¡Œçˆ¬è™«
        run: |
          npm run scrape
          
      - name: ä¸Šä¼ æˆªå›¾åˆ°GitHub
        uses: actions/upload-artifact@v4
        with:
          name: scraper-screenshots
          path: scripts/screenshots/
```

### 3. äº‘æœåŠ¡å™¨éƒ¨ç½²

```bash
# docker-compose.yml
version: '3.8'
services:
  scraper:
    build: .
    environment:
      - NODE_ENV=production
      - AI_API_KEY=${AI_API_KEY}
    volumes:
      - ./screenshots:/app/screenshots
      - ./logs:/app/logs
    restart: unless-stopped
    
  redis:
    image: redis:7-alpine
    restart: unless-stopped
    volumes:
      - redis_data:/data
```

---

## ğŸ“‹ ä½¿ç”¨ç¤ºä¾‹

### 1. å•ä¸ªçˆ¬è™«è¿è¡Œ

```javascript
// è¿è¡Œå°çº¢ä¹¦çˆ¬è™«
import { scrapeXiaohongshu } from './scripts/xiaohongshu.js';

const results = await scrapeXiaohongshu('æˆéƒ½', 20);
console.log(`è·å–åˆ° ${results.length} æ¡å°çº¢ä¹¦ç¬”è®°`);
```

### 2. æ‰¹é‡çˆ¬è™«è¿è¡Œ

```javascript
// è¿è¡Œæ‰€æœ‰çˆ¬è™«
import { scrapeXiaohongshu } from './scripts/xiaohongshu.js';
import { scrapeWeibo } from './scripts/weibo.js';
import { scrapeHousing } from './scripts/housing.js';

const cities = ['æˆéƒ½', 'å¤§ç†', 'å¦é—¨', 'é’å²›', 'æ­å·'];

for (const city of cities) {
  try {
    const [xiaohongshu, weibo, housing] = await Promise.all([
      scrapeXiaohongshu(city, 20),
      scrapeWeibo(city, 20),
      scrapeHousing(city)
    ]);
    
    console.log(`${city} çˆ¬è™«å®Œæˆ: å°çº¢ä¹¦${xiaohongsum.length}æ¡, å¾®åš${weibo.length}æ¡, æˆ¿ä»·${housing.length}ä¸ªåŒº`);
  } catch (error) {
    console.error(`${city} çˆ¬è™«å¤±è´¥:`, error.message);
  }
}
```

### 3. å®šæ—¶ä»»åŠ¡è¿è¡Œ

```javascript
// scripts/scheduler.js
import { scheduler } from './scheduler';
import { scrapeXiaohongshu } from './scripts/xiaohongshu';

// æ·»åŠ æ¯æ—¥ä»»åŠ¡
scheduler.addTask(async () => {
  const cities = ['æˆéƒ½', 'å¤§ç†', 'å¦é—¨'];
  
  for (const city of cities) {
    await scrapeXiaohongshu(city, 10);
  }
});

// å¯åŠ¨è°ƒåº¦å™¨
setInterval(() => {
  scheduler.processQueue();
}, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡é˜Ÿåˆ—
```

---

## âš ï¸ æœ€ä½³å®è·µ

### 1. ä»£ç è§„èŒƒ

```javascript
// âœ… å¥½çš„å®è·µ
class HousingScraper {
  constructor() {
    this.name = 'housing';
  }

  async scrape(cityName) {
    try {
      await this.logEvent('start', { city: cityName });
      const results = await this.doScrape(cityName);
      await this.logEvent('success', { count: results.length });
      return results;
    } catch (error) {
      await this.logEvent('error', { error: error.message });
      throw error;
    }
  }

  async logEvent(status, details) {
    await logScraperEvent(this.name, status, details);
  }

  async doScrape(cityName) {
    // å®ç°å…·ä½“çˆ¬è™«é€»è¾‘
  }
}

// âŒ é¿å…çš„å®è·µ
async function scrapeXiaohongshu(cityName) {
  // ç¼ºå°‘é”™è¯¯å¤„ç†
  const browser = await chromium.launch();
  const page = await browser.newPage();
  
  // ç¡¬ç¼–ç å»¶è¿Ÿ
  await page.waitForTimeout(3000);
  
  // æ²¡æœ‰æ—¥å¿—è®°å½•
  const notes = await page.$$('.note-item');
  
  // æ²¡æœ‰å¼‚å¸¸å¤„ç†
  for (let i = 0; i < notes.length; i++) {
    const note = notes[i];
    const title = await note.$eval(el => el.querySelector('.title').innerText);
    results.push({ title });
  }
  
  await browser.close();
  return results;
}
```

### 2. é”™è¯¯å¤„ç†

```javascript
// âœ… æ­£ç¡®çš„é”™è¯¯å¤„ç†
async function scrapeWithRetry(scraperName, city) {
  const maxRetries = 3;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await scrapeXiaohongshu(city);
    } catch (error) {
      if (attempt === maxRetries) {
        throw new Error(`çˆ¬è™«å¤±è´¥ (å°è¯•${maxRetries}æ¬¡): ${error.message}`);
      }
      
      const delay = 1000 * Math.pow(2, attempt - 1);
      console.log(`ç¬¬${attempt}æ¬¡å°è¯•å¤±è´¥ï¼Œ${delay}msåé‡è¯•`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// âŒ é¿å…çš„é”™è¯¯å¤„ç†
async function scrapeXiaohongshu(cityName) {
  try {
    return await doScrape(cityName);
  } catch (error) {
    console.error('çˆ¬è™«å¤±è´¥:', error);
    return [];
  }
}
```

### 3. é…ç½®ç®¡ç†

```javascript
// âœ… ä½¿ç”¨é…ç½®æ–‡ä»¶
// scripts/config.js
export const config = {
  apiKeys: {
    weather: process.env.WEATHER_API_KEY,
    ai: process.env.AI_API_KEY
  },
  delays: {
    default: { min: 1000, max: 3000 },
    xiaohongshu: { min: 2000, max: 5000 }
  }
};

// âŒ ç¡¬ç¼–ç é…ç½®
const API_KEY = 'your_api_key_here';
const DELAY = 2000;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£
- [Playwrightæ–‡æ¡£](https://playwright.dev/docs)
- [Playwrightçˆ¬è™«æ•™ç¨‹](https://playwright.dev/docs/intro)
- [Playwrightç¤ºä¾‹](https://github.com/microsoft/playwright/tree/main/examples)

### æŠ€æœ¯åšå®¢
- [Playwrightååçˆ¬æŠ€å·§](https://playwright.dev/docs/troubleshooting)
- [AIè¯†åˆ«çˆ¬è™«æ–¹æ¡ˆ](https://www.anthropic.com/claude)
- [Node.jsçˆ¬è™«æœ€ä½³å®è·µ](https://nodejs.dev/learn/web-scraping)

### å¼€æºé¡¹ç›®
- [Playwrightçˆ¬è™«æ¨¡æ¿](https://github.com/microsoft/playwright-examples)
- [Node.jsçˆ¬è™«æ¡†æ¶](https://github.com/ory/joes)
- [Pythonçˆ¬è™«æ¡†æ¶](https://github.com/scrapy/scrapy)

---

*æœ¬æ–‡æ¡£ç”±prd-product.mdå’Œprd-technical.mdä¸­çš„çˆ¬è™«ç« èŠ‚æ•´ç†è€Œæˆ*
*æœ€åæ›´æ–°ï¼š2025-12-26*