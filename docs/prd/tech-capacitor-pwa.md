# PRDæŠ€æœ¯æ–¹æ¡ˆï¼šCapacitor + Web API + PWA ç§»åŠ¨ç«¯æ¶æ„

> **é¡¹ç›®åç§°**ï¼šåå·èººå¹³å¯è§†åŒ–ç³»ç»Ÿ  
> **æŠ€æœ¯æ–¹æ¡ˆ**ï¼šCapacitor + Web API + PWA æ··åˆæ¶æ„  
> **ç‰ˆæœ¬**ï¼šv1.0  
> **åˆ›å»ºæ—¶é—´**ï¼š2025-12-26

---

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### æ–¹æ¡ˆç®€ä»‹

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†åŸºäº **Capacitor + Web API + PWA** çš„ç§»åŠ¨ç«¯æŠ€æœ¯æ¶æ„æ–¹æ¡ˆï¼Œæ—¨åœ¨ä¸ºåå·èººå¹³å¯è§†åŒ–ç³»ç»Ÿæä¾›è·¨å¹³å°ã€é«˜æ€§èƒ½ã€ç±»åŸç”Ÿä½“éªŒçš„ç§»åŠ¨ç«¯è§£å†³æ–¹æ¡ˆã€‚

### æ ¸å¿ƒä»·å€¼ä¸»å¼ 

- **ğŸš€ å¿«é€Ÿå¼€å‘**ï¼šåŸºäºWebæŠ€æœ¯æ ˆï¼Œä¸€æ¬¡å¼€å‘å¤šç«¯éƒ¨ç½²
- **ğŸ’° æˆæœ¬æ§åˆ¶**ï¼šé¿å…åŸç”Ÿå¼€å‘çš„é«˜æˆæœ¬å’Œé•¿å‘¨æœŸ
- **ğŸ“± ç±»åŸç”Ÿä½“éªŒ**ï¼šPWAæä¾›åŸç”Ÿåº”ç”¨èˆ¬çš„ç”¨æˆ·ä½“éªŒ
- **ğŸ”„ çƒ­æ›´æ–°**ï¼šæ— éœ€åº”ç”¨å•†åº—å®¡æ ¸å³å¯æ›´æ–°åº”ç”¨
- **ğŸŒ è·¨å¹³å°**ï¼šåŒæ—¶æ”¯æŒiOSã€Androidã€Webå¹³å°

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç§»åŠ¨ç«¯æŠ€æœ¯æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                   ç”¨æˆ·ç•Œé¢å±‚                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚   Web UI    â”‚  â”‚   Native UI â”‚  â”‚   PWA UI        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚ (SvelteKit) â”‚  â”‚ (Capacitor) â”‚  â”‚ (Service Worker)â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                   ä¸šåŠ¡é€»è¾‘å±‚                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚  åœ°å›¾æœåŠ¡    â”‚  â”‚  æ•°æ®å¯è§†åŒ–  â”‚  â”‚   ç¦»çº¿ç®¡ç†      â”‚  â”‚ â”‚
â”‚  â”‚  â”‚ (é«˜å¾·API)   â”‚  â”‚ (AntV L7)   â”‚  â”‚ (Cache API)     â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                   è®¾å¤‡è®¿é—®å±‚                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚  è®¾å¤‡API     â”‚  â”‚  å­˜å‚¨API     â”‚  â”‚   ç½‘ç»œAPI        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚ (Capacitor) â”‚  â”‚ (Capacitor) â”‚  â”‚ (Capacitor)     â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆç»„åˆ

| æŠ€æœ¯ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | ä½œç”¨ | ä¼˜åŠ¿ |
|----------|----------|------|------|
| **å‰ç«¯æ¡†æ¶** | SvelteKit | Webåº”ç”¨å¼€å‘ | é«˜æ€§èƒ½ã€è½»é‡çº§ã€æ˜“äºå­¦ä¹  |
| **è·¨å¹³å°æ¡†æ¶** | Capacitor | åŸç”ŸåŠŸèƒ½è®¿é—® | ç°ä»£åŒ–ã€æ’ä»¶ç”Ÿæ€ä¸°å¯Œ |
| **PWAæŠ€æœ¯** | Service Worker + Manifest | ç¦»çº¿æ”¯æŒå’Œå®‰è£… | ç±»åŸç”Ÿä½“éªŒã€ç¦»çº¿è®¿é—® |
| **åœ°å›¾æœåŠ¡** | é«˜å¾·åœ°å›¾ JS API | åœ°å›¾åŸºç¡€æœåŠ¡ | å›½å†…æœ€å…¨ã€æ€§èƒ½ä¼˜ç§€ |
| **æ•°æ®å¯è§†åŒ–** | AntV L7 | å¯è§†åŒ–æ¸²æŸ“ | WebGLåŠ é€Ÿã€æ•ˆæœä¸°å¯Œ |
| **UIç»„ä»¶åº“** | TailwindCSS + Headless UI | ç•Œé¢ç»„ä»¶ | ç°ä»£åŒ–ã€å¯å®šåˆ¶æ€§å¼º |
| **çŠ¶æ€ç®¡ç†** | Svelte Stores | çŠ¶æ€ç®¡ç† | è½»é‡çº§ã€å“åº”å¼ |

---

## ğŸ“± Capacitor æ¡†æ¶è¯¦è§£

### ä»€ä¹ˆæ˜¯ Capacitor

**Capacitor** æ˜¯ç”± Ionic å›¢é˜Ÿå¼€å‘çš„ç°ä»£åŒ–è·¨å¹³å°åº”ç”¨æ¡†æ¶ï¼Œæ˜¯ Cordova çš„ç»§ä»»è€…ã€‚å®ƒå…è®¸å¼€å‘è€…ä½¿ç”¨ Web æŠ€æœ¯æ„å»ºåº”ç”¨ï¼Œå¹¶å°†å…¶æ‰“åŒ…ä¸ºåŸç”Ÿç§»åŠ¨åº”ç”¨ã€‚

### æ ¸å¿ƒç‰¹æ€§

- âœ… **ç°ä»£åŒ–æ¶æ„**ï¼šåŸºäº TypeScriptï¼Œæ”¯æŒç°ä»£ Web æ ‡å‡†
- âœ… **æ’ä»¶ç”Ÿæ€**ï¼šä¸°å¯Œçš„åŸç”Ÿæ’ä»¶ï¼Œæ”¯æŒè‡ªå®šä¹‰æ’ä»¶
- âœ… **Web æ ‡å‡†**ï¼šä½¿ç”¨æ ‡å‡† Web APIï¼Œå‡å°‘å‚å•†é”å®š
- âœ… **PWA å‹å¥½**ï¼šä¸ PWA æŠ€æœ¯å®Œç¾ç»“åˆ
- âœ… **å¼€å‘ä½“éªŒ**ï¼šçƒ­é‡è½½ã€è°ƒè¯•å·¥å…·ã€CLI æ”¯æŒ

### ä¸å…¶ä»–æ–¹æ¡ˆå¯¹æ¯”

| ç‰¹æ€§ | Capacitor | Cordova | React Native | Flutter |
|------|-----------|---------|--------------|---------|
| **å¼€å‘è¯­è¨€** | WebæŠ€æœ¯ | WebæŠ€æœ¯ | JavaScript | Dart |
| **å­¦ä¹ æˆæœ¬** | ä½ | ä¸­ | ä¸­ | é«˜ |
| **æ€§èƒ½** | ä¸­ | ä¸­ | é«˜ | é«˜ |
| **åŸç”ŸåŠŸèƒ½** | ä¸°å¯Œ | ä¸°å¯Œ | ä¸°å¯Œ | ä¸°å¯Œ |
| **PWAæ”¯æŒ** | âœ… ä¼˜ç§€ | âŒ æœ‰é™ | âŒ ä¸æ”¯æŒ | âŒ ä¸æ”¯æŒ |
| **çƒ­æ›´æ–°** | âœ… æ”¯æŒ | âœ… æ”¯æŒ | âŒ æœ‰é™ | âŒ ä¸æ”¯æŒ |

---

## ğŸŒ PWA æŠ€æœ¯è¯¦è§£

### PWA æ ¸å¿ƒæ¦‚å¿µ

**Progressive Web App (PWA)** æ˜¯ Google æ¨å‡ºçš„ Web åº”ç”¨å¼€å‘ç†å¿µï¼Œæ—¨åœ¨è®© Web åº”ç”¨å…·å¤‡åŸç”Ÿåº”ç”¨çš„ç”¨æˆ·ä½“éªŒã€‚

### æ ¸å¿ƒæŠ€æœ¯ç»„ä»¶

#### 1. Service Workerï¼ˆæœåŠ¡å·¥ä½œçº¿ç¨‹ï¼‰

```javascript
// public/sw.js
const CACHE_NAME = 'gap-map-v1.0.0';
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/static/css/main.css',
  '/static/js/bundle.js',
  '/manifest.json',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png'
];

// å®‰è£…äº‹ä»¶ï¼šç¼“å­˜é™æ€èµ„æº
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('Caching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => self.skipWaiting())
  );
});

// æ¿€æ´»äº‹ä»¶ï¼šæ¸…ç†æ—§ç¼“å­˜
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== CACHE_NAME) {
              console.log('Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => self.clients.claim())
  );
});

// æ‹¦æˆªç½‘ç»œè¯·æ±‚
self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // è·³è¿‡é GET è¯·æ±‚
  if (request.method !== 'GET') return;
  
  // API è¯·æ±‚ç­–ç•¥ï¼šç½‘ç»œä¼˜å…ˆ
  if (request.url.includes('/api/')) {
    event.respondWith(
      fetch(request)
        .then((response) => {
          // ç¼“å­˜æˆåŠŸçš„ API å“åº”
          if (response.ok) {
            const responseClone = response.clone();
            caches.open(CACHE_NAME)
              .then((cache) => cache.put(request, responseClone));
          }
          return response;
        })
        .catch(() => {
          // ç½‘ç»œå¤±è´¥æ—¶ï¼Œä»ç¼“å­˜è·å–
          return caches.match(request);
        })
    );
    return;
  }
  
  // é™æ€èµ„æºç­–ç•¥ï¼šç¼“å­˜ä¼˜å…ˆ
  event.respondWith(
    caches.match(request)
      .then((response) => {
        if (response) {
          return response;
        }
        
        return fetch(request)
          .then((response) => {
            // ç¼“å­˜æ–°èµ„æº
            const responseClone = response.clone();
            caches.open(CACHE_NAME)
              .then((cache) => cache.put(request, responseClone));
            return response;
          });
      })
  );
});

// æ¨é€é€šçŸ¥å¤„ç†
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : 'æ–°çš„åŸå¸‚æ•°æ®å·²æ›´æ–°',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: '1'
    },
    actions: [
      {
        action: 'explore',
        title: 'æŸ¥çœ‹è¯¦æƒ…',
        icon: '/icons/checkmark.png'
      },
      {
        action: 'close',
        title: 'å…³é—­',
        icon: '/icons/xmark.png'
      }
    ]
  };

  event.waitUntil(
    self.registration.showNotification('åå·èººå¹³', options)
  );
});
```

#### 2. Web App Manifestï¼ˆåº”ç”¨æ¸…å•ï¼‰

```json
// public/manifest.json
{
  "name": "åå·èººå¹³å¯è§†åŒ–ç³»ç»Ÿ",
  "short_name": "åå·èººå¹³",
  "description": "æ¢ç´¢ä¸­å›½åŸå¸‚çš„åå·æŒ‡æ•°ï¼Œæ‰¾åˆ°é€‚åˆä½ çš„èººå¹³åŸå¸‚",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#1a1a2e",
  "theme_color": "#16213e",
  "orientation": "portrait-primary",
  "scope": "/",
  "lang": "zh-CN",
  "categories": ["lifestyle", "utilities", "education"],
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "shortcuts": [
    {
      "name": "åŸå¸‚æ’å",
      "short_name": "æ’å",
      "description": "æŸ¥çœ‹åŸå¸‚åå·æŒ‡æ•°æ’å",
      "url": "/ranking",
      "icons": [{ "src": "/icons/ranking.png", "sizes": "96x96" }]
    },
    {
      "name": "åœ°å›¾æ¢ç´¢",
      "short_name": "æ¢ç´¢",
      "description": "åœ¨åœ°å›¾ä¸Šæ¢ç´¢åŸå¸‚",
      "url": "/map",
      "icons": [{ "src": "/icons/map.png", "sizes": "96x96" }]
    }
  ],
  "screenshots": [
    {
      "src": "/screenshots/desktop-1.png",
      "sizes": "1280x720",
      "type": "image/png",
      "form_factor": "wide",
      "label": "æ¡Œé¢ç«¯ä¸»ç•Œé¢"
    },
    {
      "src": "/screenshots/mobile-1.png",
      "sizes": "375x667",
      "type": "image/png",
      "form_factor": "narrow",
      "label": "ç§»åŠ¨ç«¯ä¸»ç•Œé¢"
    }
  ],
  "related_applications": [],
  "prefer_related_applications": false,
  "edge_side_panel": {
    "preferred_width": 400
  }
}
```

---

## ğŸ› ï¸ å®ç°æ–¹æ¡ˆè¯¦è§£

### é¡¹ç›®ç»“æ„è®¾è®¡

```
gap-map/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ components/          # Svelte ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ stores/              # çŠ¶æ€ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ utils/               # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ api/                 # API æ¥å£
â”‚   â”‚   â”œâ”€â”€ map/                 # åœ°å›¾æœåŠ¡
â”‚   â”‚   â””â”€â”€ capacitor/           # Capacitor æ’ä»¶
â”‚   â”œâ”€â”€ routes/                  # SvelteKit è·¯ç”±
â”‚   â”œâ”€â”€ app.html                 # åº”ç”¨å…¥å£
â”‚   â””â”€â”€ app.css                  # å…¨å±€æ ·å¼
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ manifest.json            # PWA æ¸…å•
â”‚   â”œâ”€â”€ sw.js                    # Service Worker
â”‚   â”œâ”€â”€ icons/                   # åº”ç”¨å›¾æ ‡
â”‚   â””â”€â”€ screenshots/             # åº”ç”¨æˆªå›¾
â”œâ”€â”€ capacitor.config.ts          # Capacitor é…ç½®
â”œâ”€â”€ svelte.config.js             # Svelte é…ç½®
â”œâ”€â”€ vite.config.ts               # Vite é…ç½®
â””â”€â”€ package.json
```

### æ ¸å¿ƒåŠŸèƒ½å®ç°

#### 1. åœ°å›¾æœåŠ¡é›†æˆ

```typescript
// src/lib/map/index.ts
import { Scene, PointLayer, HeatmapLayer, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';
import { Geolocation } from '@capacitor/geolocation';

export class MapService {
  private scene: Scene | null = null;
  private mapInstance: any = null;
  private currentLocation: { lat: number; lng: number } | null = null;

  async initMap(container: string): Promise<void> {
    try {
      // åˆå§‹åŒ–é«˜å¾·åœ°å›¾
      this.mapInstance = new GaodeMap({
        center: [108, 35],
        zoom: 5,
        pitch: 40,
        style: 'darkblue',
        viewMode: '3D',
        token: process.env.AMAP_KEY
      });

      // åˆå§‹åŒ– L7 åœºæ™¯
      this.scene = new Scene({
        id: container,
        map: this.mapInstance,
      });

      // è·å–ç”¨æˆ·ä½ç½®
      await this.getCurrentLocation();
      
      // æ·»åŠ åœ°å›¾äº‹ä»¶ç›‘å¬
      this.setupMapEvents();
      
      console.log('åœ°å›¾åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      console.error('åœ°å›¾åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  }

  private async getCurrentLocation(): Promise<void> {
    try {
      // ä½¿ç”¨ Capacitor è·å–ä½ç½®
      const position = await Geolocation.getCurrentPosition({
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      });

      this.currentLocation = {
        lat: position.coords.latitude,
        lng: position.coords.longitude
      };

      // è®¾ç½®åœ°å›¾ä¸­å¿ƒ
      if (this.mapInstance) {
        this.mapInstance.setCenter([this.currentLocation.lng, this.currentLocation.lat]);
        this.mapInstance.setZoom(10);
      }

      console.log('å½“å‰ä½ç½®:', this.currentLocation);
    } catch (error) {
      console.warn('è·å–ä½ç½®å¤±è´¥:', error);
      // ä½¿ç”¨é»˜è®¤ä½ç½®
      this.currentLocation = { lat: 39.9042, lng: 116.4074 };
    }
  }

  async addHeatmapLayer(data: any[]): Promise<void> {
    if (!this.scene) return;

    const heatmapLayer = new HeatmapLayer({
      zIndex: 5,
      blend: 'normal'
    })
      .source(data, {
        parser: {
          type: 'json',
          x: 'lng',
          y: 'lat'
        }
      })
      .size('tangpingIndex', [0, 100])
      .style({
        intensity: 2,
        radius: 50000,
        gradient: {
          0.3: '#5CCEA1',
          0.7: '#F6BD16',
          1.0: '#FF6B6B'
        }
      });

    this.scene.addLayer(heatmapLayer);
  }

  async addCityMarkers(cities: any[]): Promise<void> {
    if (!this.scene) return;

    const cityLayer = new PointLayer({
      zIndex: 10,
      animate: {
        enable: true,
        speed: 0.5,
        rings: 3
      }
    })
      .source(cities, {
        parser: {
          type: 'json',
          x: 'lng',
          'y': 'lat'
        }
      })
      .shape('circle')
      .size('population', [10, 50])
      .color('tangpingIndex', [
        '#5CCEA1',
        '#F6BD16',
        '#FF6B6B'
      ])
      .active(true)
      .style({
        opacity: 0.8,
        strokeWidth: 1,
        stroke: '#fff'
      });

    // æ·»åŠ äº¤äº’
    cityLayer.on('click', (feature: any) => {
      this.showCityDetails(feature.properties);
    });

    this.scene.addLayer(cityLayer);
  }

  private setupMapEvents(): void {
    if (!this.mapInstance) return;

    // æ‰‹åŠ¿ç¼©æ”¾ä¼˜åŒ–
    this.mapInstance.on('zoomend', () => {
      const zoom = this.mapInstance.getZoom();
      this.updateDataVisibility(zoom);
    });

    // åœ°å›¾æ‹–æ‹½ç»“æŸ
    this.mapInstance.on('moveend', () => {
      const bounds = this.mapInstance.getBounds();
      this.loadCitiesInView(bounds);
    });
  }

  private showCityDetails(city: any): void {
    // è§¦å‘å…¨å±€äº‹ä»¶ï¼Œæ˜¾ç¤ºåŸå¸‚è¯¦æƒ…
    window.dispatchEvent(new CustomEvent('citySelected', {
      detail: city
    }));
  }

  private updateDataVisibility(zoom: number): void {
    // æ ¹æ®ç¼©æ”¾çº§åˆ«è°ƒæ•´æ•°æ®å¯è§æ€§
    if (zoom > 8) {
      // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
    } else {
      // æ˜¾ç¤ºæ¦‚è¦ä¿¡æ¯
    }
  }

  private async loadCitiesInView(bounds: any): Promise<void> {
    // åŠ è½½è§†é‡å†…çš„åŸå¸‚æ•°æ®
    try {
      const response = await fetch(`/api/cities?bounds=${JSON.stringify(bounds)}`);
      const cities = await response.json();
      await this.addCityMarkers(cities);
    } catch (error) {
      console.error('åŠ è½½åŸå¸‚æ•°æ®å¤±è´¥:', error);
    }
  }

  destroy(): void {
    if (this.scene) {
      this.scene.destroy();
      this.scene = null;
    }
  }
}
```

#### 2. ç§»åŠ¨ç«¯æ‰‹åŠ¿ä¼˜åŒ–

```typescript
// src/lib/components/MobileMap.svelte
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { MapService } from '$lib/map';
  import { StatusBar, Style } from '@capacitor/status-bar';
  import { App } from '@capacitor/app';

  export let mapService: MapService;
  let container: HTMLElement;
  let touchStartDistance = 0;
  let touchStartScale = 1;
  let isPinching = false;

  onMount(async () => {
    // åˆå§‹åŒ–çŠ¶æ€æ 
    await StatusBar.setStyle({ style: Style.Dark });
    await StatusBar.setBackgroundColor({ color: '#1a1a2e' });

    // åˆå§‹åŒ–åœ°å›¾
    mapService = new MapService();
    await mapService.initMap(container);

    // è®¾ç½®ç§»åŠ¨ç«¯æ‰‹åŠ¿
    setupMobileGestures();

    // è®¾ç½®è¿”å›é”®ç›‘å¬
    App.addListener('backButtonPressed', () => {
      handleBackButton();
    });
  });

  function setupMobileGestures(): void {
    if (!container) return;

    // åŒæŒ‡ç¼©æ”¾ + æ—¶é—´è½´å‹ç¼©
    container.addEventListener('touchstart', handleTouchStart, { passive: false });
    container.addEventListener('touchmove', handleTouchMove, { passive: false });
    container.addEventListener('touchend', handleTouchEnd, { passive: false });
  }

  function handleTouchStart(event: TouchEvent): void {
    if (event.touches.length === 2) {
      isPinching = true;
      touchStartDistance = getTouchDistance(event.touches);
      touchStartScale = mapService.getMapInstance().getZoom();
      event.preventDefault();
    }
  }

  function handleTouchMove(event: TouchEvent): void {
    if (isPinching && event.touches.length === 2) {
      const distance = getTouchDistance(event.touches);
      const scale = (distance / touchStartDistance) * touchStartScale;
      
      // åŒæ—¶ç¼©æ”¾åœ°å›¾å’Œå‹ç¼©æ—¶é—´è½´
      mapService.getMapInstance().setZoom(scale);
      compressTimeline(scale);
      
      event.preventDefault();
    }
  }

  function handleTouchEnd(event: TouchEvent): void {
    if (event.touches.length < 2) {
      isPinching = false;
    }
  }

  function getTouchDistance(touches: TouchList): number {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function compressTimeline(scale: number): void {
    // æ ¹æ®ç¼©æ”¾çº§åˆ«è°ƒæ•´æ—¶é—´è½´æ˜¾ç¤º
    const monthsVisible = Math.max(1, Math.floor(12 / scale));
    
    // è§¦å‘æ—¶é—´è½´æ›´æ–°äº‹ä»¶
    window.dispatchEvent(new CustomEvent('timelineCompress', {
      detail: { monthsVisible, scale }
    }));
  }

  function handleBackButton(): void {
    // å¤„ç†è¿”å›é”®é€»è¾‘
    const currentRoute = window.location.pathname;
    
    if (currentRoute !== '/') {
      window.history.back();
    } else {
      // é€€å‡ºåº”ç”¨ç¡®è®¤
      if (confirm('ç¡®å®šè¦é€€å‡ºåº”ç”¨å—ï¼Ÿ')) {
        App.exitApp();
      }
    }
  }

  onDestroy(() => {
    if (mapService) {
      mapService.destroy();
    }
  });
</script>

<div bind:this={container} class="map-container"></div>

<style>
  .map-container {
    width: 100%;
    height: 100vh;
    touch-action: pan-x pan-y pinch-zoom;
    position: relative;
    overflow: hidden;
  }

  /* é˜²æ­¢åŒå‡»ç¼©æ”¾ */
  .map-container {
    touch-action: manipulation;
  }

  /* ä¼˜åŒ–æ»šåŠ¨æ€§èƒ½ */
  .map-container * {
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
  }
</style>
```

#### 3. ç¦»çº¿æ•°æ®ç®¡ç†

```typescript
// src/lib/offline/index.ts
import { Storage } from '@capacitor/storage';

export class OfflineManager {
  private static instance: OfflineManager;
  private dbName = 'GapMapDB';
  private version = 1;
  private db: IDBDatabase | null = null;

  static getInstance(): OfflineManager {
    if (!OfflineManager.instance) {
      OfflineManager.instance = new OfflineManager();
    }
    return OfflineManager.instance;
  }

  async initDatabase(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;

        // åŸå¸‚æ•°æ®å­˜å‚¨
        if (!db.objectStoreNames.contains('cities')) {
          const cityStore = db.createObjectStore('cities', { keyPath: 'id' });
          cityStore.createIndex('province', 'province', { unique: false });
          cityStore.createIndex('tangpingIndex', 'tangpingIndex', { unique: false });
        }

        // ç”¨æˆ·åå¥½å­˜å‚¨
        if (!db.objectStoreNames.contains('preferences')) {
          db.createObjectStore('preferences', { keyPath: 'key' });
        }

        // ç¼“å­˜å…ƒæ•°æ®
        if (!db.objectStoreNames.contains('cacheMetadata')) {
          const metadataStore = db.createObjectStore('cacheMetadata', { keyPath: 'key' });
          metadataStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }

  async cacheCities(cities: any[]): Promise<void> {
    if (!this.db) await this.initDatabase();

    const transaction = this.db!.transaction(['cities'], 'readwrite');
    const store = transaction.objectStore('cities');

    for (const city of cities) {
      store.put({
        ...city,
        cachedAt: Date.now(),
        version: '1.0'
      });
    }

    // æ›´æ–°ç¼“å­˜å…ƒæ•°æ®
    await this.updateCacheMetadata('cities', {
      count: cities.length,
      lastUpdated: Date.now()
    });

    return new Promise((resolve, reject) => {
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => reject(transaction.error);
    });
  }

  async getCachedCities(province?: string): Promise<any[]> {
    if (!this.db) await this.initDatabase();

    const transaction = this.db!.transaction(['cities'], 'readonly');
    const store = transaction.objectStore('cities');

    return new Promise((resolve, reject) => {
      const request = province 
        ? store.index('province').getAll(province)
        : store.getAll();

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async syncData(): Promise<void> {
    try {
      // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
      const isOnline = navigator.onLine;
      if (!isOnline) {
        console.log('ç¦»çº¿æ¨¡å¼ï¼Œè·³è¿‡æ•°æ®åŒæ­¥');
        return;
      }

      // è·å–æœ€åæ›´æ–°æ—¶é—´
      const lastSync = await this.getLastSyncTime();
      const now = Date.now();
      const syncInterval = 24 * 60 * 60 * 1000; // 24å°æ—¶

      if (now - lastSync < syncInterval) {
        console.log('æ•°æ®åŒæ­¥é—´éš”æœªåˆ°ï¼Œè·³è¿‡åŒæ­¥');
        return;
      }

      // åŒæ­¥åŸå¸‚æ•°æ®
      const response = await fetch('/api/cities/sync');
      const cities = await response.json();
      
      if (cities.length > 0) {
        await this.cacheCities(cities);
        console.log(`åŒæ­¥äº† ${cities.length} ä¸ªåŸå¸‚æ•°æ®`);
      }

      // æ›´æ–°åŒæ­¥æ—¶é—´
      await Storage.set({
        key: 'lastSyncTime',
        value: now.toString()
      });

    } catch (error) {
      console.error('æ•°æ®åŒæ­¥å¤±è´¥:', error);
    }
  }

  private async updateCacheMetadata(key: string, metadata: any): Promise<void> {
    if (!this.db) await this.initDatabase();

    const transaction = this.db!.transaction(['cacheMetadata'], 'readwrite');
    const store = transaction.objectStore('cacheMetadata');

    store.put({
      key,
      ...metadata,
      updatedAt: Date.now()
    });

    return new Promise((resolve, reject) => {
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => reject(transaction.error);
    });
  }

  private async getLastSyncTime(): Promise<number> {
    try {
      const { value } = await Storage.get({ key: 'lastSyncTime' });
      return value ? parseInt(value, 10) : 0;
    } catch {
      return 0;
    }
  }

  async clearCache(): Promise<void> {
    if (!this.db) await this.initDatabase();

    const stores = ['cities', 'preferences', 'cacheMetadata'];
    
    for (const storeName of stores) {
      const transaction = this.db!.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      store.clear();
    }

    // æ¸…é™¤å­˜å‚¨
    await Storage.clear();
    
    console.log('ç¼“å­˜å·²æ¸…é™¤');
  }

  async getCacheStats(): Promise<any> {
    if (!this.db) await this.initDatabase();

    const stats = {
      cities: 0,
      lastSync: 0,
      cacheSize: 0
    };

    // è·å–åŸå¸‚æ•°é‡
    const cities = await this.getCachedCities();
    stats.cities = cities.length;

    // è·å–æœ€ååŒæ­¥æ—¶é—´
    stats.lastSync = await this.getLastSyncTime();

    // ä¼°ç®—ç¼“å­˜å¤§å°
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      stats.cacheSize = estimate.usage || 0;
    }

    return stats;
  }
}
```

---

## ğŸ“¦ Capacitor é…ç½®

### åŸºç¡€é…ç½®æ–‡ä»¶

```typescript
// capacitor.config.ts
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.gapmap.app',
  appName: 'åå·èººå¹³',
  webDir: 'build',
  server: {
    androidScheme: 'https',
    cleartext: true,
    allowNavigation: ['*']
  },
  plugins: {
    SplashScreen: {
      launchShowDuration: 2000,
      launchAutoHide: true,
      backgroundColor: "#1a1a2e",
      androidSplashResourceName: "splash",
      androidScaleType: "CENTER_CROP",
      showSpinner: true,
      spinnerStyle: "large",
      spinnerColor: "#999999",
      splashFullScreen: true,
      splashImmersive: true,
      layoutName: "launch_screen",
      useDialog: true
    },
    StatusBar: {
      style: 'DARK',
      backgroundColor: '#1a1a2e'
    },
    App: {
      appendUserAgent: 'GapMap/1.0'
    },
    PushNotifications: {
      presentationOptions: ["badge", "sound", "alert"]
    },
    Camera: {
      permissions: ["camera", "photos"]
    },
    Geolocation: {
      permissions: ["location"]
    },
    Network: {
      permissions: ["network"]
    }
  },
  android: {
    allowMixedContent: true,
    captureInput: true,
    webContentsDebuggingEnabled: process.env.NODE_ENV === 'development'
  },
  ios: {
    contentInset: "automatic",
    allowsInlineMediaPlayback: true,
    overrideUserAgent: "GapMap-iOS/1.0"
  }
};

export default config;
```

### æƒé™é…ç½®

#### Android æƒé™

```xml
<!-- android/app/src/main/AndroidManifest.xml -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.gapmap.app">
    
    <!-- ç½‘ç»œæƒé™ -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    
    <!-- ä½ç½®æƒé™ -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    
    <!-- ç›¸æœºæƒé™ -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    
    <!-- æ¨é€æƒé™ -->
    <uses-permission android:name="android.permission.VIBRATE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    
    <!-- åº”ç”¨é…ç½® -->
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme"
        android:usesCleartextTraffic="true">
        
        <!-- ç½‘ç»œå®‰å…¨é…ç½® -->
        <meta-data
            android:name="android.webkit.WebView.MetricsOptOut"
            android:value="true" />
            
        <!-- åœ°å›¾é…ç½® -->
        <meta-data
            android:name="com.amap.api.v2.apikey"
            android:value="${AMAP_API_KEY}" />
    </application>
</manifest>
```

#### iOS æƒé™

```xml
<!-- ios/App/App/Info.plist -->
<dict>
    <!-- ä½ç½®æƒé™ -->
    <key>NSLocationWhenInUseUsageDescription</key>
    <string>åå·èººå¹³éœ€è¦è®¿é—®æ‚¨çš„ä½ç½®æ¥æ˜¾ç¤ºé™„è¿‘çš„åŸå¸‚ä¿¡æ¯</string>
    <key>NSLocationAlwaysAndWhenInUseUsageDescription</key>
    <string>åå·èººå¹³éœ€è¦è®¿é—®æ‚¨çš„ä½ç½®æ¥æä¾›æ›´å¥½çš„æœåŠ¡</string>
    
    <!-- ç›¸æœºæƒé™ -->
    <key>NSCameraUsageDescription</key>
    <string>åå·èººå¹³éœ€è¦è®¿é—®ç›¸æœºæ¥æ‹æ‘„å®åœ°è€ƒå¯Ÿç…§ç‰‡</string>
    <key>NSPhotoLibraryUsageDescription</key>
    <string>åå·èººå¹³éœ€è¦è®¿é—®ç›¸å†Œæ¥é€‰æ‹©å®åœ°è€ƒå¯Ÿç…§ç‰‡</string>
    
    <!-- æ¨é€æƒé™ -->
    <key>UIBackgroundModes</key>
    <array>
        <string>background-fetch</string>
        <string>remote-notification</string>
    </array>
    
    <!-- ç½‘ç»œé…ç½® -->
    <key>NSAppTransportSecurity</key>
    <dict>
        <key>NSAllowsArbitraryLoads</key>
        <true/>
    </dict>
    
    <!-- åœ°å›¾é…ç½® -->
    <key>AMapApiKey</key>
    <string>${AMAP_API_KEY}</string>
</dict>
```

---

## ğŸš€ å¼€å‘å’Œéƒ¨ç½²æµç¨‹

### å¼€å‘ç¯å¢ƒæ­å»º

```bash
# 1. åˆ›å»ºé¡¹ç›®
npm create svelte@latest gap-map-mobile
cd gap-map-mobile

# 2. å®‰è£…ä¾èµ–
npm install

# 3. å®‰è£… Capacitor
npm install @capacitor/core @capacitor/cli
npm install @capacitor/android @capacitor/ios

# 4. å®‰è£…æ’ä»¶
npm install @capacitor/geolocation
npm install @capacitor/camera
npm install @capacitor/status-bar
npm install @capacitor/push-notifications
npm install @capacitor/network
npm install @capacitor/storage

# 5. å®‰è£…åœ°å›¾åº“
npm install @antv/l7 @antv/l7-maps

# 6. åˆå§‹åŒ– Capacitor
npx cap init "åå·èººå¹³" "com.gapmap.app"

# 7. æ„å»ºé¡¹ç›®
npm run build

# 8. æ·»åŠ å¹³å°
npx cap add android
npx cap add ios

# 9. åŒæ­¥ä»£ç 
npx cap sync
```

### å¼€å‘è„šæœ¬é…ç½®

```json
// package.json
{
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview",
    "android": "npm run build && npx cap open android",
    "ios": "npm run build && npx cap open ios",
    "sync": "npm run build && npx cap sync",
    "run:android": "npm run build && npx cap run android",
    "run:ios": "npm run build && npx cap run ios",
    "pwa:build": "npm run build && workbox generateSW workbox-config.js",
    "pwa:serve": "npm run build && npx serve dist"
  },
  "devDependencies": {
    "@capacitor/cli": "^5.0.0",
    "@sveltejs/adapter-static": "^2.0.0",
    "workbox-cli": "^7.0.0"
  }
}
```

### æ„å»ºå’Œå‘å¸ƒæµç¨‹

#### 1. Web ç‰ˆæœ¬å‘å¸ƒ

```bash
# æ„å»º Web ç‰ˆæœ¬
npm run build

# ç”Ÿæˆ Service Worker
npm run pwa:build

# éƒ¨ç½²åˆ°é™æ€æ‰˜ç®¡
npm run deploy
```

#### 2. Android ç‰ˆæœ¬å‘å¸ƒ

```bash
# æ„å»º Android APK
npm run build
npx cap sync android
npx cap open android

# åœ¨ Android Studio ä¸­ï¼š
# 1. Build â†’ Generate Signed Bundle / APK
# 2. é€‰æ‹© APK æˆ– AAB
# 3. é…ç½®ç­¾åä¿¡æ¯
# 4. ç”Ÿæˆå‘å¸ƒåŒ…
```

#### 3. iOS ç‰ˆæœ¬å‘å¸ƒ

```bash
# æ„å»º iOS ç‰ˆæœ¬
npm run build
npx cap sync ios
npx cap open ios

# åœ¨ Xcode ä¸­ï¼š
# 1. é€‰æ‹©ç›®æ ‡è®¾å¤‡æˆ–æ¨¡æ‹Ÿå™¨
# 2. Product â†’ Archive
# 3. ä¸Šä¼ åˆ° App Store Connect
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. åŠ è½½æ€§èƒ½ä¼˜åŒ–

```typescript
// src/lib/performance/loader.ts
export class PerformanceOptimizer {
  private static instance: PerformanceOptimizer;

  static getInstance(): PerformanceOptimizer {
    if (!PerformanceOptimizer.instance) {
      PerformanceOptimizer.instance = new PerformanceOptimizer();
    }
    return PerformanceOptimizer.instance;
  }

  // é¢„åŠ è½½å…³é”®èµ„æº
  async preloadCriticalResources(): Promise<void> {
    const criticalResources = [
      '/api/cities/featured',
      '/static/css/main.css',
      '/static/js/bundle.js'
    ];

    const promises = criticalResources.map(url => 
      fetch(url).then(response => {
        if (response.ok) {
          return response.text();
        }
        throw new Error(`Failed to preload ${url}`);
      })
    );

    try {
      await Promise.all(promises);
      console.log('å…³é”®èµ„æºé¢„åŠ è½½å®Œæˆ');
    } catch (error) {
      console.warn('èµ„æºé¢„åŠ è½½å¤±è´¥:', error);
    }
  }

  // æ‡’åŠ è½½éå…³é”®èµ„æº
  lazyLoadImages(): void {
    const images = document.querySelectorAll('img[data-src]');
    
    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target as HTMLImageElement;
          img.src = img.dataset.src!;
          img.removeAttribute('data-src');
          imageObserver.unobserve(img);
        }
      });
    });

    images.forEach(img => imageObserver.observe(img));
  }

  // ä»£ç åˆ†å‰²
  async loadMapModule(): Promise<any> {
    try {
      const mapModule = await import('$lib/map');
      return mapModule;
    } catch (error) {
      console.error('åœ°å›¾æ¨¡å—åŠ è½½å¤±è´¥:', error);
      throw error;
    }
  }

  // ç›‘æ§æ€§èƒ½æŒ‡æ ‡
  monitorPerformance(): void {
    // ç›‘æ§é¦–æ¬¡å†…å®¹ç»˜åˆ¶
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.name === 'first-contentful-paint') {
          console.log('FCP:', entry.startTime);
        }
      }
    }).observe({ entryTypes: ['paint'] });

    // ç›‘æ§æœ€å¤§å†…å®¹ç»˜åˆ¶
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.log('LCP:', entry.startTime);
      }
    }).observe({ entryTypes: ['largest-contentful-paint'] });

    // ç›‘æ§ç´¯ç§¯å¸ƒå±€åç§»
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.log('CLS:', entry.value);
      }
    }).observe({ entryTypes: ['layout-shift'] });
  }
}
```

### 2. å†…å­˜ç®¡ç†ä¼˜åŒ–

```typescript
// src/lib/performance/memory.ts
export class MemoryManager {
  private static instance: MemoryManager;
  private cache = new Map<string, any>();
  private maxCacheSize = 50; // æœ€å¤§ç¼“å­˜æ¡ç›®æ•°

  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }

  // æ™ºèƒ½ç¼“å­˜
  set(key: string, value: any, ttl: number = 300000): void { // 5åˆ†é’Ÿé»˜è®¤TTL
    // æ£€æŸ¥ç¼“å­˜å¤§å°
    if (this.cache.size >= this.maxCacheSize) {
      this.evictOldest();
    }

    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      ttl
    });
  }

  get(key: string): any | null {
    const item = this.cache.get(key);
    
    if (!item) return null;

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }

    return item.value;
  }

  private evictOldest(): void {
    let oldestKey = '';
    let oldestTime = Date.now();

    for (const [key, item] of this.cache.entries()) {
      if (item.timestamp < oldestTime) {
        oldestTime = item.timestamp;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  // æ¸…ç†è¿‡æœŸç¼“å­˜
  cleanup(): void {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key);
      }
    }
  }

  // è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
  getMemoryUsage(): any {
    if ('memory' in performance) {
      return {
        used: (performance as any).memory.usedJSHeapSize,
        total: (performance as any).memory.totalJSHeapSize,
        limit: (performance as any).memory.jsHeapSizeLimit
      };
    }
    return null;
  }
}
```

---

## ğŸ”§ è°ƒè¯•å’Œæµ‹è¯•

### 1. å¼€å‘è°ƒè¯•

```typescript
// src/lib/debug/debug.ts
export class DebugManager {
  private static instance: DebugManager;
  private isDebugMode = process.env.NODE_ENV === 'development';

  static getInstance(): DebugManager {
    if (!DebugManager.instance) {
      DebugManager.instance = new DebugManager();
    }
    return DebugManager.instance;
  }

  // æ—¥å¿—è®°å½•
  log(message: string, data?: any): void {
    if (!this.isDebugMode) return;
    
    console.log(`[GapMap] ${message}`, data || '');
  }

  // é”™è¯¯è®°å½•
  error(message: string, error?: any): void {
    console.error(`[GapMap Error] ${message}`, error || '');
    
    // å‘é€é”™è¯¯æŠ¥å‘Š
    this.reportError(message, error);
  }

  // æ€§èƒ½ç›‘æ§
  measure(name: string, fn: Function): any {
    if (!this.isDebugMode) return fn();

    const start = performance.now();
    const result = fn();
    const end = performance.now();
    
    console.log(`[GapMap Performance] ${name}: ${end - start}ms`);
    return result;
  }

  // ç½‘ç»œè¯·æ±‚ç›‘æ§
  monitorNetwork(): void {
    const originalFetch = window.fetch;
    
    window.fetch = async (...args) => {
      const start = performance.now();
      
      try {
        const response = await originalFetch(...args);
        const end = performance.now();
        
        this.log(`Network Request: ${args[0]} - ${response.status} (${end - start}ms)`);
        return response;
      } catch (error) {
        const end = performance.now();
        this.error(`Network Error: ${args[0]} (${end - start}ms)`, error);
        throw error;
      }
    };
  }

  private async reportError(message: string, error: any): Promise<void> {
    try {
      await fetch('/api/debug/error', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message,
          error: error?.stack || error,
          userAgent: navigator.userAgent,
          timestamp: Date.now(),
          url: window.location.href
        })
      });
    } catch (reportError) {
      console.error('Error reporting failed:', reportError);
    }
  }
}
```

### 2. è‡ªåŠ¨åŒ–æµ‹è¯•

```typescript
// src/tests/map.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { MapService } from '$lib/map';

describe('MapService', () => {
  let mapService: MapService;

  beforeEach(() => {
    mapService = new MapService();
  });

  it('should initialize map successfully', async () => {
    const container = document.createElement('div');
    container.id = 'test-map';
    document.body.appendChild(container);

    await expect(mapService.initMap('test-map')).resolves.not.toThrow();
  });

  it('should add heatmap layer', async () => {
    const testData = [
      { lng: 116.4074, lat: 39.9042, tangpingIndex: 80 },
      { lng: 121.4737, lat: 31.2304, tangpingIndex: 60 }
    ];

    await expect(mapService.addHeatmapLayer(testData)).resolves.not.toThrow();
  });

  it('should handle location errors gracefully', async () => {
    // Mock geolocation error
    const originalGeolocation = navigator.geolocation;
    Object.defineProperty(navigator, 'geolocation', {
      value: {
        getCurrentPosition: (success, error) => error(new Error('Location denied'))
      },
      writable: true
    });

    await expect(mapService.getCurrentLocation()).resolves.not.toThrow();

    // Restore
    Object.defineProperty(navigator, 'geolocation', {
      value: originalGeolocation,
      writable: true
    });
  });
});
```

---

## ğŸ“ˆ ç›‘æ§å’Œåˆ†æ

### 1. æ€§èƒ½ç›‘æ§

```typescript
// src/lib/analytics/performance.ts
export class PerformanceAnalytics {
  private static instance: PerformanceAnalytics;

  static getInstance(): PerformanceAnalytics {
    if (!PerformanceAnalytics.instance) {
      PerformanceAnalytics.instance = new PerformanceAnalytics();
    }
    return PerformanceAnalytics.instance;
  }

  // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
  collectMetrics(): any {
    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
    const paint = performance.getEntriesByType('paint');

    return {
      // é¡µé¢åŠ è½½æ—¶é—´
      pageLoad: navigation.loadEventEnd - navigation.navigationStart,
      
      // é¦–æ¬¡å†…å®¹ç»˜åˆ¶
      firstContentfulPaint: paint.find(p => p.name === 'first-contentful-paint')?.startTime,
      
      // æœ€å¤§å†…å®¹ç»˜åˆ¶
      largestContentfulPaint: this.getLCP(),
      
      // ç´¯ç§¯å¸ƒå±€åç§»
      cumulativeLayoutShift: this.getCLS(),
      
      // é¦–æ¬¡è¾“å…¥å»¶è¿Ÿ
      firstInputDelay: this.getFID(),
      
      // å†…å­˜ä½¿ç”¨
      memoryUsage: this.getMemoryUsage()
    };
  }

  private getLCP(): number {
    // å®ç° LCP è®¡ç®—
    return 0;
  }

  private getCLS(): number {
    // å®ç° CLS è®¡ç®—
    return 0;
  }

  private getFID(): number {
    // å®ç° FID è®¡ç®—
    return 0;
  }

  private getMemoryUsage(): any {
    if ('memory' in performance) {
      return {
        used: (performance as any).memory.usedJSHeapSize,
        total: (performance as any).memory.totalJSHeapSize,
        limit: (performance as any).memory.jsHeapSizeLimit
      };
    }
    return null;
  }

  // å‘é€æ€§èƒ½æ•°æ®
  async sendMetrics(): Promise<void> {
    const metrics = this.collectMetrics();
    
    try {
      await fetch('/api/analytics/performance', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          ...metrics,
          timestamp: Date.now(),
          userAgent: navigator.userAgent,
          url: window.location.href
        })
      });
    } catch (error) {
      console.error('Failed to send performance metrics:', error);
    }
  }
}
```

---

## ğŸ”’ å®‰å…¨æ€§è€ƒè™‘

### 1. æ•°æ®å®‰å…¨

```typescript
// src/lib/security/crypto.ts
export class SecurityManager {
  private static instance: SecurityManager;
  private encryptionKey: string;

  static getInstance(): SecurityManager {
    if (!SecurityManager.instance) {
      SecurityManager.instance = new SecurityManager();
    }
    return SecurityManager.instance;
  }

  constructor() {
    this.encryptionKey = process.env.ENCRYPTION_KEY || 'default-key';
  }

  // æ•°æ®åŠ å¯†
  async encrypt(data: string): Promise<string> {
    try {
      const encoder = new TextEncoder();
      const dataBuffer = encoder.encode(data);
      const keyBuffer = await this.getKey();
      
      const encrypted = await crypto.subtle.encrypt(
        {
          name: 'AES-GCM',
          iv: crypto.getRandomValues(new Uint8Array(12))
        },
        keyBuffer,
        dataBuffer
      );

      return btoa(String.fromCharCode(...new Uint8Array(encrypted)));
    } catch (error) {
      console.error('Encryption failed:', error);
      throw error;
    }
  }

  // æ•°æ®è§£å¯†
  async decrypt(encryptedData: string): Promise<string> {
    try {
      const encryptedBuffer = new Uint8Array(
        atob(encryptedData).split('').map(char => char.charCodeAt(0))
      );
      const keyBuffer = await this.getKey();
      
      const decrypted = await crypto.subtle.decrypt(
        {
          name: 'AES-GCM',
          iv: crypto.getRandomValues(new Uint8Array(12))
        },
        keyBuffer,
        encryptedBuffer
      );

      return new TextDecoder().decode(decrypted);
    } catch (error) {
      console.error('Decryption failed:', error);
      throw error;
    }
  }

  private async getKey(): Promise<CryptoKey> {
    const encoder = new TextEncoder();
    const keyData = encoder.encode(this.encryptionKey);
    
    return crypto.subtle.importKey(
      'raw',
      keyData,
      { name: 'AES-GCM' },
      false,
      ['encrypt', 'decrypt']
    );
  }

  // éªŒè¯æ•°æ®å®Œæ•´æ€§
  async verifyIntegrity(data: string, signature: string): Promise<boolean> {
    try {
      const encoder = new TextEncoder();
      const dataBuffer = encoder.encode(data);
      const signatureBuffer = new Uint8Array(
        atob(signature).split('').map(char => char.charCodeAt(0))
      );
      
      const keyBuffer = await this.getKey();
      
      const isValid = await crypto.subtle.verify(
        'HMAC',
        keyBuffer,
        signatureBuffer,
        dataBuffer
      );

      return isValid;
    } catch (error) {
      console.error('Integrity verification failed:', error);
      return false;
    }
  }
}
```

### 2. ç½‘ç»œå®‰å…¨

```typescript
// src/lib/security/network.ts
export class NetworkSecurity {
  private static instance: NetworkSecurity;
  private trustedDomains = ['gapmap.com', 'api.gapmap.com'];

  static getInstance(): NetworkSecurity {
    if (!NetworkSecurity.instance) {
      NetworkSecurity.instance = new NetworkSecurity();
    }
    return NetworkSecurity.instance;
  }

  // éªŒè¯è¯·æ±‚åŸŸå
  validateRequest(url: string): boolean {
    try {
      const urlObj = new URL(url);
      return this.trustedDomains.includes(urlObj.hostname);
    } catch {
      return false;
    }
  }

  // æ·»åŠ å®‰å…¨å¤´
  addSecurityHeaders(): void {
    // CSP å¤´éƒ¨
    const cspMeta = document.createElement('meta');
    cspMeta.httpEquiv = 'Content-Security-Policy';
    cspMeta.content = `
      default-src 'self';
      script-src 'self' 'unsafe-inline' https://webapi.amap.com;
      style-src 'self' 'unsafe-inline';
      img-src 'self' data: https:;
      connect-src 'self' https://api.gapmap.com https://restapi.amap.com;
      font-src 'self';
      object-src 'none';
      base-uri 'self';
      form-action 'self';
      frame-ancestors 'none';
    `.replace(/\s+/g, ' ').trim();
    
    document.head.appendChild(cspMeta);

    // å…¶ä»–å®‰å…¨å¤´
    const headers = [
      { httpEquiv: 'X-Content-Type-Options', content: 'nosniff' },
      { httpEquiv: 'X-Frame-Options', content: 'DENY' },
      { httpEquiv: 'X-XSS-Protection', content: '1; mode=block' },
      { httpEquiv: 'Referrer-Policy', content: 'strict-origin-when-cross-origin' }
    ];

    headers.forEach(header => {
      const meta = document.createElement('meta');
      Object.assign(meta, header);
      document.head.appendChild(meta);
    });
  }

  // è¯·æ±‚ç­¾å
  async signRequest(url: string, data: any): Promise<string> {
    const timestamp = Date.now().toString();
    const nonce = crypto.getRandomValues(new Uint8Array(16)).toString();
    
    const payload = {
      url,
      data,
      timestamp,
      nonce
    };

    const encoder = new TextEncoder();
    const payloadBuffer = encoder.encode(JSON.stringify(payload));
    
    const signature = await crypto.subtle.sign(
      'HMAC',
      await this.getSigningKey(),
      payloadBuffer
    );

    return btoa(String.fromCharCode(...new Uint8Array(signature)));
  }

  private async getSigningKey(): Promise<CryptoKey> {
    const encoder = new TextEncoder();
    const keyData = encoder.encode(process.env.SIGNING_KEY || 'default-signing-key');
    
    return crypto.subtle.importKey(
      'raw',
      keyData,
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );
  }
}
```

---

## ğŸ“‹ é¡¹ç›®å®æ–½è®¡åˆ’

### Phase 1: åŸºç¡€æ¶æ„æ­å»ºï¼ˆ1-2å‘¨ï¼‰

- âœ… **ç¯å¢ƒé…ç½®**
  - SvelteKit é¡¹ç›®åˆå§‹åŒ–
  - Capacitor é…ç½®å’Œæ’ä»¶å®‰è£…
  - å¼€å‘ç¯å¢ƒæ­å»º

- âœ… **æ ¸å¿ƒç»„ä»¶å¼€å‘**
  - åœ°å›¾æœåŠ¡å°è£…
  - åŸºç¡€ UI ç»„ä»¶
  - è·¯ç”±é…ç½®

- âœ… **PWA åŸºç¡€åŠŸèƒ½**
  - Service Worker é…ç½®
  - Web App Manifest
  - ç¦»çº¿ç¼“å­˜ç­–ç•¥

### Phase 2: åŠŸèƒ½å®ç°ï¼ˆ2-3å‘¨ï¼‰

- âœ… **åœ°å›¾åŠŸèƒ½**
  - é«˜å¾·åœ°å›¾é›†æˆ
  - AntV L7 å¯è§†åŒ–
  - æ‰‹åŠ¿æ“ä½œä¼˜åŒ–

- âœ… **ç§»åŠ¨ç«¯ç‰¹æ€§**
  - å®šä½æœåŠ¡
  - ç›¸æœºé›†æˆ
  - æ¨é€é€šçŸ¥

- âœ… **ç¦»çº¿åŠŸèƒ½**
  - æ•°æ®ç¼“å­˜
  - ç¦»çº¿åœ°å›¾
  - åŒæ­¥æœºåˆ¶

### Phase 3: ä¼˜åŒ–å’Œæµ‹è¯•ï¼ˆ1-2å‘¨ï¼‰

- âœ… **æ€§èƒ½ä¼˜åŒ–**
  - ä»£ç åˆ†å‰²
  - æ‡’åŠ è½½
  - å†…å­˜ç®¡ç†

- âœ… **æµ‹è¯•å®Œå–„**
  - å•å…ƒæµ‹è¯•
  - é›†æˆæµ‹è¯•
  - æ€§èƒ½æµ‹è¯•

- âœ… **å®‰å…¨åŠ å›º**
  - æ•°æ®åŠ å¯†
  - ç½‘ç»œå®‰å…¨
  - æƒé™ç®¡ç†

### Phase 4: å‘å¸ƒå’Œéƒ¨ç½²ï¼ˆ1å‘¨ï¼‰

- âœ… **åº”ç”¨æ‰“åŒ…**
  - Android APK/AAB ç”Ÿæˆ
  - iOS IPA æ„å»º
  - Web ç‰ˆæœ¬éƒ¨ç½²

- âœ… **åº”ç”¨å•†åº—å‘å¸ƒ**
  - Google Play Store
  - Apple App Store
  - Web ç‰ˆæœ¬ä¸Šçº¿

---

## ğŸ“Š æˆæœ¬æ•ˆç›Šåˆ†æ

### å¼€å‘æˆæœ¬å¯¹æ¯”

| å¼€å‘æ–¹å¼ | å¼€å‘å‘¨æœŸ | äººåŠ›æˆæœ¬ | ç»´æŠ¤æˆæœ¬ | æ€»ä½“æˆæœ¬ |
|----------|----------|----------|----------|----------|
| **åŸç”Ÿå¼€å‘** | 3-4ä¸ªæœˆ | é«˜ | ä¸­ | é«˜ |
| **React Native** | 2-3ä¸ªæœˆ | ä¸­é«˜ | ä¸­ | ä¸­é«˜ |
| **Flutter** | 2-3ä¸ªæœˆ | ä¸­ | ä¸­ | ä¸­ |
| **Capacitor + PWA** | 1-2ä¸ªæœˆ | ä¸­ | ä½ | **ä½** |

### æŠ€æœ¯ä¼˜åŠ¿

- âœ… **å¿«é€Ÿè¿­ä»£**ï¼šçƒ­æ›´æ–°ï¼Œæ— éœ€åº”ç”¨å•†åº—å®¡æ ¸
- âœ… **æˆæœ¬æ§åˆ¶**ï¼šä¸€å¥—ä»£ç ï¼Œå¤šç«¯éƒ¨ç½²
- âœ… **ç”¨æˆ·ä½“éªŒ**ï¼šç±»åŸç”Ÿä½“éªŒï¼Œç¦»çº¿æ”¯æŒ
- âœ… **SEOå‹å¥½**ï¼šWeb ç‰ˆæœ¬å¯è¢«æœç´¢å¼•æ“ç´¢å¼•
- âœ… **ç»´æŠ¤ç®€å•**ï¼šç»Ÿä¸€çš„ä»£ç åº“å’ŒæŠ€æœ¯æ ˆ

---

## âš ï¸ é£é™©è¯„ä¼°ä¸åº”å¯¹

### æŠ€æœ¯é£é™©

| é£é™©é¡¹ | å½±å“ç¨‹åº¦ | å‘ç”Ÿæ¦‚ç‡ | åº”å¯¹ç­–ç•¥ |
|--------|----------|----------|----------|
| **æ€§èƒ½é—®é¢˜** | ä¸­ | ä¸­ | æ€§èƒ½ç›‘æ§ã€ä»£ç ä¼˜åŒ– |
| **å…¼å®¹æ€§é—®é¢˜** | ä¸­ | ä½ | å……åˆ†æµ‹è¯•ã€æ¸è¿›å¢å¼º |
| **æ’ä»¶é™åˆ¶** | ä½ | ä¸­ | è‡ªå®šä¹‰æ’ä»¶å¼€å‘ |
| **å®¡æ ¸é£é™©** | ä½ | ä½ | éµå®ˆå¹³å°è§„èŒƒ |

### ä¸šåŠ¡é£é™©

| é£é™©é¡¹ | å½±å“ç¨‹åº¦ | å‘ç”Ÿæ¦‚ç‡ | åº”å¯¹ç­–ç•¥ |
|--------|----------|----------|----------|
| **ç”¨æˆ·æ¥å—åº¦** | ä¸­ | ä½ | ç”¨æˆ·ä½“éªŒä¼˜åŒ– |
| **æ•°æ®å®‰å…¨** | é«˜ | ä½ | åŠ å¯†å­˜å‚¨ã€å®‰å…¨ä¼ è¾“ |
| **æœåŠ¡ä¾èµ–** | ä¸­ | ä¸­ | å¤šäº‘éƒ¨ç½²ã€å®¹ç¾å¤‡ä»½ |

---

## ğŸ“š æ€»ç»“

### æŠ€æœ¯æ–¹æ¡ˆä¼˜åŠ¿

1. **ğŸš€ å¼€å‘æ•ˆç‡é«˜**ï¼šåŸºäº Web æŠ€æœ¯æ ˆï¼Œå­¦ä¹ æˆæœ¬ä½ï¼Œå¼€å‘å‘¨æœŸçŸ­
2. **ğŸ’° æˆæœ¬æ§åˆ¶å¥½**ï¼šä¸€å¥—ä»£ç å¤šç«¯éƒ¨ç½²ï¼Œå¤§å¹…é™ä½å¼€å‘å’Œç»´æŠ¤æˆæœ¬
3. **ğŸ“± ç”¨æˆ·ä½“éªŒä½³**ï¼šPWA æä¾›ç±»åŸç”Ÿä½“éªŒï¼Œæ”¯æŒç¦»çº¿è®¿é—®
4. **ğŸ”„ è¿­ä»£é€Ÿåº¦å¿«**ï¼šæ”¯æŒçƒ­æ›´æ–°ï¼Œæ— éœ€åº”ç”¨å•†åº—å®¡æ ¸å³å¯å‘å¸ƒæ›´æ–°
5. **ğŸŒ è¦†ç›–é¢å¹¿**ï¼šåŒæ—¶æ”¯æŒ Webã€iOSã€Android ä¸‰ä¸ªå¹³å°

### é€‚ç”¨åœºæ™¯

- âœ… **å†…å®¹å±•ç¤ºç±»åº”ç”¨**ï¼šåœ°å›¾ã€æ•°æ®å¯è§†åŒ–ç­‰
- âœ… **å·¥å…·ç±»åº”ç”¨**ï¼šæŸ¥è¯¢ã€è®¡ç®—ã€è½¬æ¢ç­‰
- âœ… **ç”µå•†ç±»åº”ç”¨**ï¼šå•†å“å±•ç¤ºã€è´­ç‰©æµç¨‹ç­‰
- âœ… **ç¤¾äº¤ç±»åº”ç”¨**ï¼šä¿¡æ¯åˆ†äº«ã€äº’åŠ¨äº¤æµç­‰

### ä¸é€‚ç”¨åœºæ™¯

- âŒ **é«˜æ€§èƒ½æ¸¸æˆ**ï¼šéœ€è¦å¤§é‡è®¡ç®—å’Œå›¾å½¢æ¸²æŸ“
- âŒ **å¤æ‚éŸ³è§†é¢‘å¤„ç†**ï¼šéœ€è¦åº•å±‚ç¡¬ä»¶æ”¯æŒ
- âŒ **é‡åº¦ä¾èµ–åŸç”ŸåŠŸèƒ½**ï¼šéœ€è¦å¤§é‡ç‰¹å®šç¡¬ä»¶ API

---

**ç»“è®º**ï¼šCapacitor + Web API + PWA æ–¹æ¡ˆéå¸¸é€‚åˆåå·èººå¹³å¯è§†åŒ–ç³»ç»Ÿçš„ç§»åŠ¨ç«¯å¼€å‘éœ€æ±‚ã€‚å®ƒèƒ½å¤Ÿåœ¨ä¿è¯ç”¨æˆ·ä½“éªŒçš„åŒæ—¶ï¼Œå¤§å¹…é™ä½å¼€å‘æˆæœ¬å’Œç»´æŠ¤å¤æ‚åº¦ï¼Œæ˜¯ä¸€ä¸ªæ€§ä»·æ¯”æé«˜çš„æŠ€æœ¯é€‰æ‹©ã€‚

---

*æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*  
*æœ€åæ›´æ–°ï¼š2025-12-26*  
*ä½œè€…ï¼šæŠ€æœ¯å›¢é˜Ÿ*